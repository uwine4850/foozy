{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the foozy documentation! foozy is a framework focused on flexibility and extensibility. Most of the framework components depend on interfaces, so they are easy to replace. For example, the mapper package can be omitted, as can the form package. Also, the framework has several built-in packages for convenience, such as the auth package for working with users. You can read more about the other packages in the rest of the documentation. An example of a project written using the framework. For example, you can look at the getting started section .","title":"General"},{"location":"#welcome-to-the-foozy-documentation","text":"foozy is a framework focused on flexibility and extensibility. Most of the framework components depend on interfaces, so they are easy to replace. For example, the mapper package can be omitted, as can the form package. Also, the framework has several built-in packages for convenience, such as the auth package for working with users. You can read more about the other packages in the rest of the documentation. An example of a project written using the framework. For example, you can look at the getting started section .","title":"Welcome to the foozy documentation!"},{"location":"getting_started/","text":"Getting started This section will describe in detail how to get started with the framework and create a minimally working project. You can read more about all the packages used in the rest of the documentation. Install You need to use the appropriate command to install the framework: go get github.com/uwine4850/foozy Naturally you need to have golang 1.20 or more installed. Also, after using some packages you need to install dependencies. To do this, just use the go mod tidy command. Creating a project The following will describe the successive steps in creating a project. They must be performed in sequence to minimally initialize the project. Commands and configuration To create a project you need to use several console commands. To do this you need to initialize the cmd package . One way will be shown below, it is just one implementation, do not consider it a single correct implementation. Create a command directory. Create a commad.go file. Populate the command.go file with the following code: package main import \"github.com/uwine4850/foozy/pkg/cmd\" func main() { if err := cmd.Run(); err != nil { panic(err) } } Note : most often, after import the github.com/uwine4850/foozy/pkg/cmd package, you need to run the go mod tidy command. Call the go run command/command.go cnf-init ./cnf command . Generating the cnf/cnf_init/cnf_init.go file. From the generated file, you need to import the initcnf.InitCnf() function . The command/command.go file now looks like this: package main import ( initcnf \"<project-mod>/cnf/init_cnf\" \"github.com/uwine4850/foozy/pkg/cmd\" ) func main() { initcnf.InitCnf() if err := cmd.Run(); err != nil { panic(err) } } This is to know the path to the configuration file. Next, you need to exec the go run command/command.go cnf-gen command . This will generate a configuration file here (if the user has not changed anything) cnf/config.yaml . End After these operations, the console commands and the cofiguration file are ready for use. You can read more details here: Console commands . Configuration file . Launching the first page To start, a complete example of a minimal server just for copying and a quick test will be shown. After startup you can see the page at this address http://localhost:7000/page . Start the server with the go run <filename>.go command. Note: Most likely you will need to call the go mod tidy command. package main import ( \"net/http\" initcnf \"tee/cnf/init_cnf\" \"github.com/uwine4850/foozy/pkg/database\" \"github.com/uwine4850/foozy/pkg/interfaces\" \"github.com/uwine4850/foozy/pkg/router\" \"github.com/uwine4850/foozy/pkg/router/manager\" \"github.com/uwine4850/foozy/pkg/router/middlewares\" \"github.com/uwine4850/foozy/pkg/server\" ) func main() { initcnf.InitCnf() newManager := manager.NewManager( manager.NewOneTimeData(), nil, nil, ) newMiddlewares := middlewares.NewMiddlewares() newAdapter := router.NewAdapter(newManager, newMiddlewares) newRouter := router.NewRouter(newAdapter) newRouter.Register(router.MethodGET, \"/page\", func(w http.ResponseWriter, r *http.Request, manager interfaces.Manager) error { w.Write([]byte(\"My first page!\")) return nil }) newServer := server.NewServer(\":7000\", newRouter, nil) if err := newServer.Start(); err != nil { panic(err) } } Below is a more detailed breakdown of all of this. Initializing the configuration for use in the project. This only needs to be done once, as the configuration just needs to be loaded. This means that you only need to call this function once for a single session. It does not matter where this function is called, but it must be called for the session. Read more here . initcnf.InitCnf() Manager initialization. This object is used in many places in the framework, but you need to initialize it here. It is mandatory to pass manager.NewOneTimeData() . Render and TODO: add link DatabasePool are optional if you don't plan to use a templating engine or database. newManager := manager.NewManager( manager.NewOneTimeData(), nil, nil, ) But for future use, full initialization of the manager is recommended. newRender, err := tmlengine.NewRender() if err != nil { panic(err) } newManager := manager.NewManager( manager.NewOneTimeData(), newRender, database.NewDatabasePool(), ) Initializing the middleware. Read more here . newMiddlewares := middlewares.NewMiddlewares() Initializing the adapter . It is needed for starting and preliminary preparation of handlers. newAdapter := router.NewAdapter(newManager, newMiddlewares) Initialize the router to handle http routes. newRouter := router.NewRouter(newAdapter) A handler that will process the selected routes. An error is returned, which will be handled by a special method specified in the adapter . newRouter.Register(router.MethodGET, \"/page\", func(w http.ResponseWriter, r *http.Request, manager interfaces.Manager) error { w.Write([]byte(\"My first page!\")) return nil }) This shows the simplest possible output of data to a page using w.Write([]byte(\u201cMy first page!\u201d)) . For more advanced output, you need to use a templating engine . But before that you need to create HTML file and make full initialization of the manager , which is shown above. newRouter.Register(router.MethodGET, \"/page\", func(w http.ResponseWriter, r *http.Request, manager interfaces.Manager) error { manager.Render().SetTemplatePath(\"index.html\") if err := manager.Render().RenderTemplate(w, r); err != nil { return err } return nil }) Starting a TODO: add link server to process http requests. Here processing is started without TODO: add link cors . newServer := server.NewServer(\":7000\", newRouter, nil) if err := newServer.Start(); err != nil { panic(err) } This is the complete minimal initialization of the framework. For more detailed information you need to look at other documentation or TODO: add link example project .","title":"Getting started"},{"location":"getting_started/#getting-started","text":"This section will describe in detail how to get started with the framework and create a minimally working project. You can read more about all the packages used in the rest of the documentation.","title":"Getting started"},{"location":"getting_started/#install","text":"You need to use the appropriate command to install the framework: go get github.com/uwine4850/foozy Naturally you need to have golang 1.20 or more installed. Also, after using some packages you need to install dependencies. To do this, just use the go mod tidy command.","title":"Install"},{"location":"getting_started/#creating-a-project","text":"The following will describe the successive steps in creating a project. They must be performed in sequence to minimally initialize the project.","title":"Creating a project"},{"location":"getting_started/#commands-and-configuration","text":"To create a project you need to use several console commands. To do this you need to initialize the cmd package . One way will be shown below, it is just one implementation, do not consider it a single correct implementation. Create a command directory. Create a commad.go file. Populate the command.go file with the following code: package main import \"github.com/uwine4850/foozy/pkg/cmd\" func main() { if err := cmd.Run(); err != nil { panic(err) } } Note : most often, after import the github.com/uwine4850/foozy/pkg/cmd package, you need to run the go mod tidy command. Call the go run command/command.go cnf-init ./cnf command . Generating the cnf/cnf_init/cnf_init.go file. From the generated file, you need to import the initcnf.InitCnf() function . The command/command.go file now looks like this: package main import ( initcnf \"<project-mod>/cnf/init_cnf\" \"github.com/uwine4850/foozy/pkg/cmd\" ) func main() { initcnf.InitCnf() if err := cmd.Run(); err != nil { panic(err) } } This is to know the path to the configuration file. Next, you need to exec the go run command/command.go cnf-gen command . This will generate a configuration file here (if the user has not changed anything) cnf/config.yaml . End After these operations, the console commands and the cofiguration file are ready for use. You can read more details here: Console commands . Configuration file .","title":"Commands and configuration"},{"location":"getting_started/#launching-the-first-page","text":"To start, a complete example of a minimal server just for copying and a quick test will be shown. After startup you can see the page at this address http://localhost:7000/page . Start the server with the go run <filename>.go command. Note: Most likely you will need to call the go mod tidy command. package main import ( \"net/http\" initcnf \"tee/cnf/init_cnf\" \"github.com/uwine4850/foozy/pkg/database\" \"github.com/uwine4850/foozy/pkg/interfaces\" \"github.com/uwine4850/foozy/pkg/router\" \"github.com/uwine4850/foozy/pkg/router/manager\" \"github.com/uwine4850/foozy/pkg/router/middlewares\" \"github.com/uwine4850/foozy/pkg/server\" ) func main() { initcnf.InitCnf() newManager := manager.NewManager( manager.NewOneTimeData(), nil, nil, ) newMiddlewares := middlewares.NewMiddlewares() newAdapter := router.NewAdapter(newManager, newMiddlewares) newRouter := router.NewRouter(newAdapter) newRouter.Register(router.MethodGET, \"/page\", func(w http.ResponseWriter, r *http.Request, manager interfaces.Manager) error { w.Write([]byte(\"My first page!\")) return nil }) newServer := server.NewServer(\":7000\", newRouter, nil) if err := newServer.Start(); err != nil { panic(err) } } Below is a more detailed breakdown of all of this. Initializing the configuration for use in the project. This only needs to be done once, as the configuration just needs to be loaded. This means that you only need to call this function once for a single session. It does not matter where this function is called, but it must be called for the session. Read more here . initcnf.InitCnf() Manager initialization. This object is used in many places in the framework, but you need to initialize it here. It is mandatory to pass manager.NewOneTimeData() . Render and TODO: add link DatabasePool are optional if you don't plan to use a templating engine or database. newManager := manager.NewManager( manager.NewOneTimeData(), nil, nil, ) But for future use, full initialization of the manager is recommended. newRender, err := tmlengine.NewRender() if err != nil { panic(err) } newManager := manager.NewManager( manager.NewOneTimeData(), newRender, database.NewDatabasePool(), ) Initializing the middleware. Read more here . newMiddlewares := middlewares.NewMiddlewares() Initializing the adapter . It is needed for starting and preliminary preparation of handlers. newAdapter := router.NewAdapter(newManager, newMiddlewares) Initialize the router to handle http routes. newRouter := router.NewRouter(newAdapter) A handler that will process the selected routes. An error is returned, which will be handled by a special method specified in the adapter . newRouter.Register(router.MethodGET, \"/page\", func(w http.ResponseWriter, r *http.Request, manager interfaces.Manager) error { w.Write([]byte(\"My first page!\")) return nil }) This shows the simplest possible output of data to a page using w.Write([]byte(\u201cMy first page!\u201d)) . For more advanced output, you need to use a templating engine . But before that you need to create HTML file and make full initialization of the manager , which is shown above. newRouter.Register(router.MethodGET, \"/page\", func(w http.ResponseWriter, r *http.Request, manager interfaces.Manager) error { manager.Render().SetTemplatePath(\"index.html\") if err := manager.Render().RenderTemplate(w, r); err != nil { return err } return nil }) Starting a TODO: add link server to process http requests. Here processing is started without TODO: add link cors . newServer := server.NewServer(\":7000\", newRouter, nil) if err := newServer.Start(); err != nil { panic(err) } This is the complete minimal initialization of the framework. For more detailed information you need to look at other documentation or TODO: add link example project .","title":"Launching the first page"},{"location":"builtin/builtin/","text":"Builtin This section contains ready-made implementations that can be used in the project. It is not necessary to use them, but in some cases you will need to create your own implementation. middlewares auth \u2014 tools for auth. csrf \u2014 working with CSRF tokens. globalflow \u2014 working with the globalflow package. auth \u2014 built-in user account management.","title":"Builtin"},{"location":"builtin/builtin/#builtin","text":"This section contains ready-made implementations that can be used in the project. It is not necessary to use them, but in some cases you will need to create your own implementation.","title":"Builtin"},{"location":"builtin/builtin/#middlewares","text":"auth \u2014 tools for auth. csrf \u2014 working with CSRF tokens. globalflow \u2014 working with the globalflow package. auth \u2014 built-in user account management.","title":"middlewares"},{"location":"builtin/auth/auth/","text":"auth This package is designed for full interaction with the user account. More detailed information on how to use this package can be found in the tests . AuthQuery interface Interface is designed to abstract from the database during authentication. Any database can implement this interface and use it in the auth package. AuthQuery.UserByUsername With username returns an UnsafeUser object that stores user data from the database. UserByUsername(username string) (*UnsafeUser, error) AuthQuery.UserById With id returns an UnsafeUser object that stores user data from the database. UserById(id any) (*UnsafeUser, error) AuthQuery.CreateNewUser Creates a new user in the database. The password must be encrypted in advance before passing it to this method. CreateNewUser(username string, hashPassword string) (result map[string]interface{}, err error) AuthQuery.ChangePassword Changes the user's password. The password must be encrypted in advance before passing it to this method. ChangePassword(userId string, newHashPassword string) (result map[string]interface{}, err error) UnsafeUser Full user data. Not safe, should be used with caution. type UnsafeUser struct { Id int `db:\"id\"` Username string `db:\"username\"` Password string `db:\"password\"` } User Public user data that can be accessed by everyone. type User struct { Id int `db:\"id\"` Username string `db:\"username\"` } Cookie Presentation of authentication cookies. type Cookie struct { UID int KeyDate time.Time } JWTClaims Claims for JWT authentication. type JWTClaims struct { jwt.RegisteredClaims Id int `json:\"id\"` } Auth Structure is designed to manage user authentication. It can be used to create a user, check the correctness of the login data, change the password and check the availability of the user. Auth.RegisterUser Registers the user in the database. It also checks the password and makes sure that there is no user with that login.<br Returns the ID of the new user. func (a *Auth) RegisterUser(username string, password string) (userId int, err error) { user, err := a.db.UserByUsername(username) if err != nil { return 0, err } if user != nil { return 0, ErrUserAlreadyExist{username} } if len(password) < 6 { return 0, ErrShortPassword{} } if len(username) < 3 { return 0, ErrShortUsername{} } hashPass, err := HashPassword(password) if err != nil { return 0, err } result, err := a.db.CreateNewUser(username, hashPass) if err != nil { return 0, err } insertUserId, ok := result[\"insertID\"].(int64) if !ok { return 0, &ErrUserRegistration{} } return int(insertUserId), nil } Auth.LoginUser Check if the password and login are the same. If there was no error returns an User object with user data. func (a *Auth) LoginUser(username string, password string) (*User, error) { user, err := a.db.UserByUsername(username) if err != nil { return nil, err } if user == nil { return nil, ErrUserNotExist{username} } err = ComparePassword(user.Password, password) if err != nil { return nil, err } return &User{ user.Id, user.Username, }, nil } Auth.UpdateAuthCookie Updates the cookie encoding. IMPORTANT : to work, you need to decode the data; accordingly, in the hashKey and blockKey fields you need to use the keys with which they were encoded. Next, the function itself will take new keys from ManagerConf. func (a *Auth) UpdateAuthCookie(hashKey []byte, blockKey []byte, r *http.Request) error { var authCookie Cookie if err := cookies.ReadSecureCookieData(hashKey, blockKey, r, namelib.AUTH.COOKIE_AUTH, &authCookie); err != nil { return err } if err := a.AddAuthCookie(authCookie.UID); err != nil { return err } return nil } Auth.AddAuthCookie Adds the user's authentication cipher to the cookie. func (a *Auth) AddAuthCookie(uid int) error { k := a.manager.Key().Get32BytesKey() if err := cookies.CreateSecureCookieData([]byte(k.HashKey()), []byte(k.BlockKey()), a.w, &http.Cookie{ Name: namelib.AUTH.COOKIE_AUTH, Path: \"/\", HttpOnly: true, Secure: true, }, &Cookie{UID: uid, KeyDate: a.manager.Key().Get32BytesKey().Date()}); err != nil { return err } authDate := a.manager.Key().Get32BytesKey().Date() if err := cookies.CreateSecureNoHMACCookieData([]byte(k.StaticKey()), a.w, &http.Cookie{ Name: namelib.AUTH.COOKIE_AUTH_DATE, Path: \"/\", HttpOnly: true, Secure: true, }, &authDate); err != nil { return err } return nil } Auth.ChangePassword Changes the current user password. func (a *Auth) ChangePassword(username string, oldPassword string, newPassword string) error { user, err := a.db.UserByUsername(username) if err != nil { return err } if user == nil { return ErrUserNotExist{username} } if len(newPassword) < 6 { return ErrShortPassword{} } err = ComparePassword(user.Password, oldPassword) if err != nil { return err } password, err := HashPassword(newPassword) if err != nil { return err } if _, err := a.db.ChangePassword(username, password); err != nil { return err } return nil } UserByUsername Checks if the user is in the database. If it is found, it returns information about it. func UserByUsername(db AuthQuery, username string) (*User, error) { user, err := db.UserByUsername(username) if err != nil { return nil, err } return &User{ Id: user.Id, Username: user.Username, }, nil } UserByID Searches for a user by ID and returns it. func UserByID(db AuthQuery, id any) (*User, error) { user, err := db.UserById(id) if err != nil { return nil, err } return &User{ Id: user.Id, Username: user.Username, }, nil } CreateMysqlAuthTable Creates a user authentication table. func CreateMysqlAuthTable(dbInteraction interfaces.DatabaseInteraction, databaseName string) error { sql := fmt.Sprintf(\"CREATE TABLE IF NOT EXISTS `%s`.`%s` \"+ \"(`id` INT NOT NULL AUTO_INCREMENT , \"+ \"`username` VARCHAR(200) NOT NULL , \"+ \"`password` TEXT NOT NULL , PRIMARY KEY (`id`))\", databaseName, namelib.AUTH.AUTH_TABLE) _, err := dbInteraction.SyncQ().Query(sql) if err != nil { return err } return nil } HashPassword Generating a password hash from a string. func HashPassword(password string) (string, error) { bytesPass := []byte(password) fromPassword, err := bcrypt.GenerateFromPassword(bytesPass, bcrypt.DefaultCost) if err != nil { return \"\", err } return string(fromPassword), nil } ComparePassword Check if the password hash and the password itself match. func ComparePassword(hashedPassword string, password string) error { err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password)) if err != nil { return ErrPasswordsDontMatch{} } return nil }","title":"Auth"},{"location":"builtin/auth/auth/#auth","text":"This package is designed for full interaction with the user account. More detailed information on how to use this package can be found in the tests .","title":"auth"},{"location":"builtin/auth/auth/#authquery-interface","text":"Interface is designed to abstract from the database during authentication. Any database can implement this interface and use it in the auth package.","title":"AuthQuery interface"},{"location":"builtin/auth/auth/#authqueryuserbyusername","text":"With username returns an UnsafeUser object that stores user data from the database. UserByUsername(username string) (*UnsafeUser, error)","title":"AuthQuery.UserByUsername"},{"location":"builtin/auth/auth/#authqueryuserbyid","text":"With id returns an UnsafeUser object that stores user data from the database. UserById(id any) (*UnsafeUser, error)","title":"AuthQuery.UserById"},{"location":"builtin/auth/auth/#authquerycreatenewuser","text":"Creates a new user in the database. The password must be encrypted in advance before passing it to this method. CreateNewUser(username string, hashPassword string) (result map[string]interface{}, err error)","title":"AuthQuery.CreateNewUser"},{"location":"builtin/auth/auth/#authquerychangepassword","text":"Changes the user's password. The password must be encrypted in advance before passing it to this method. ChangePassword(userId string, newHashPassword string) (result map[string]interface{}, err error)","title":"AuthQuery.ChangePassword"},{"location":"builtin/auth/auth/#unsafeuser","text":"Full user data. Not safe, should be used with caution. type UnsafeUser struct { Id int `db:\"id\"` Username string `db:\"username\"` Password string `db:\"password\"` }","title":"UnsafeUser"},{"location":"builtin/auth/auth/#user","text":"Public user data that can be accessed by everyone. type User struct { Id int `db:\"id\"` Username string `db:\"username\"` }","title":"User"},{"location":"builtin/auth/auth/#cookie","text":"Presentation of authentication cookies. type Cookie struct { UID int KeyDate time.Time }","title":"Cookie"},{"location":"builtin/auth/auth/#jwtclaims","text":"Claims for JWT authentication. type JWTClaims struct { jwt.RegisteredClaims Id int `json:\"id\"` }","title":"JWTClaims"},{"location":"builtin/auth/auth/#auth_1","text":"Structure is designed to manage user authentication. It can be used to create a user, check the correctness of the login data, change the password and check the availability of the user.","title":"Auth"},{"location":"builtin/auth/auth/#authregisteruser","text":"Registers the user in the database. It also checks the password and makes sure that there is no user with that login.<br Returns the ID of the new user. func (a *Auth) RegisterUser(username string, password string) (userId int, err error) { user, err := a.db.UserByUsername(username) if err != nil { return 0, err } if user != nil { return 0, ErrUserAlreadyExist{username} } if len(password) < 6 { return 0, ErrShortPassword{} } if len(username) < 3 { return 0, ErrShortUsername{} } hashPass, err := HashPassword(password) if err != nil { return 0, err } result, err := a.db.CreateNewUser(username, hashPass) if err != nil { return 0, err } insertUserId, ok := result[\"insertID\"].(int64) if !ok { return 0, &ErrUserRegistration{} } return int(insertUserId), nil }","title":"Auth.RegisterUser"},{"location":"builtin/auth/auth/#authloginuser","text":"Check if the password and login are the same. If there was no error returns an User object with user data. func (a *Auth) LoginUser(username string, password string) (*User, error) { user, err := a.db.UserByUsername(username) if err != nil { return nil, err } if user == nil { return nil, ErrUserNotExist{username} } err = ComparePassword(user.Password, password) if err != nil { return nil, err } return &User{ user.Id, user.Username, }, nil }","title":"Auth.LoginUser"},{"location":"builtin/auth/auth/#authupdateauthcookie","text":"Updates the cookie encoding. IMPORTANT : to work, you need to decode the data; accordingly, in the hashKey and blockKey fields you need to use the keys with which they were encoded. Next, the function itself will take new keys from ManagerConf. func (a *Auth) UpdateAuthCookie(hashKey []byte, blockKey []byte, r *http.Request) error { var authCookie Cookie if err := cookies.ReadSecureCookieData(hashKey, blockKey, r, namelib.AUTH.COOKIE_AUTH, &authCookie); err != nil { return err } if err := a.AddAuthCookie(authCookie.UID); err != nil { return err } return nil }","title":"Auth.UpdateAuthCookie"},{"location":"builtin/auth/auth/#authaddauthcookie","text":"Adds the user's authentication cipher to the cookie. func (a *Auth) AddAuthCookie(uid int) error { k := a.manager.Key().Get32BytesKey() if err := cookies.CreateSecureCookieData([]byte(k.HashKey()), []byte(k.BlockKey()), a.w, &http.Cookie{ Name: namelib.AUTH.COOKIE_AUTH, Path: \"/\", HttpOnly: true, Secure: true, }, &Cookie{UID: uid, KeyDate: a.manager.Key().Get32BytesKey().Date()}); err != nil { return err } authDate := a.manager.Key().Get32BytesKey().Date() if err := cookies.CreateSecureNoHMACCookieData([]byte(k.StaticKey()), a.w, &http.Cookie{ Name: namelib.AUTH.COOKIE_AUTH_DATE, Path: \"/\", HttpOnly: true, Secure: true, }, &authDate); err != nil { return err } return nil }","title":"Auth.AddAuthCookie"},{"location":"builtin/auth/auth/#authchangepassword","text":"Changes the current user password. func (a *Auth) ChangePassword(username string, oldPassword string, newPassword string) error { user, err := a.db.UserByUsername(username) if err != nil { return err } if user == nil { return ErrUserNotExist{username} } if len(newPassword) < 6 { return ErrShortPassword{} } err = ComparePassword(user.Password, oldPassword) if err != nil { return err } password, err := HashPassword(newPassword) if err != nil { return err } if _, err := a.db.ChangePassword(username, password); err != nil { return err } return nil }","title":"Auth.ChangePassword"},{"location":"builtin/auth/auth/#userbyusername","text":"Checks if the user is in the database. If it is found, it returns information about it. func UserByUsername(db AuthQuery, username string) (*User, error) { user, err := db.UserByUsername(username) if err != nil { return nil, err } return &User{ Id: user.Id, Username: user.Username, }, nil }","title":"UserByUsername"},{"location":"builtin/auth/auth/#userbyid","text":"Searches for a user by ID and returns it. func UserByID(db AuthQuery, id any) (*User, error) { user, err := db.UserById(id) if err != nil { return nil, err } return &User{ Id: user.Id, Username: user.Username, }, nil }","title":"UserByID"},{"location":"builtin/auth/auth/#createmysqlauthtable","text":"Creates a user authentication table. func CreateMysqlAuthTable(dbInteraction interfaces.DatabaseInteraction, databaseName string) error { sql := fmt.Sprintf(\"CREATE TABLE IF NOT EXISTS `%s`.`%s` \"+ \"(`id` INT NOT NULL AUTO_INCREMENT , \"+ \"`username` VARCHAR(200) NOT NULL , \"+ \"`password` TEXT NOT NULL , PRIMARY KEY (`id`))\", databaseName, namelib.AUTH.AUTH_TABLE) _, err := dbInteraction.SyncQ().Query(sql) if err != nil { return err } return nil }","title":"CreateMysqlAuthTable"},{"location":"builtin/auth/auth/#hashpassword","text":"Generating a password hash from a string. func HashPassword(password string) (string, error) { bytesPass := []byte(password) fromPassword, err := bcrypt.GenerateFromPassword(bytesPass, bcrypt.DefaultCost) if err != nil { return \"\", err } return string(fromPassword), nil }","title":"HashPassword"},{"location":"builtin/auth/auth/#comparepassword","text":"Check if the password hash and the password itself match. func ComparePassword(hashedPassword string, password string) error { err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password)) if err != nil { return ErrPasswordsDontMatch{} } return nil }","title":"ComparePassword"},{"location":"builtin/globalflow/globalflow/","text":"builtin globalflow KeyUpdater Function for use in TODO:add link GlobalFlow.AddNotWaitTask . Updates the hashKey and blockKey keys after a selected period of time. func KeyUpdater(delaySec int) globalflow.Task { return func(manager interfaces.Manager) { time.Sleep(time.Duration(delaySec) * time.Second) manager.Key().Get32BytesKey().GenerateBytesKeys(32) } }","title":"Globalflow"},{"location":"builtin/globalflow/globalflow/#builtin-globalflow","text":"","title":"builtin globalflow"},{"location":"builtin/globalflow/globalflow/#keyupdater","text":"Function for use in TODO:add link GlobalFlow.AddNotWaitTask . Updates the hashKey and blockKey keys after a selected period of time. func KeyUpdater(delaySec int) globalflow.Task { return func(manager interfaces.Manager) { time.Sleep(time.Duration(delaySec) * time.Second) manager.Key().Get32BytesKey().GenerateBytesKeys(32) } }","title":"KeyUpdater"},{"location":"builtin/mddl/auth/","text":"auth middlewares Auth Auth is used to determine when to change the AUTH cookie encoding. When keys are changed, a change date is set. If the date does not match, then you need to change the encoding. It is important to note that only previous keys are saved; accordingly, it is impossible to update the encoding if two or more key iterations have passed, because the old keys are no longer known. This middleware should not work on the login page. Therefore, you need to specify the loginUrl correctly. The onErr element is used for error management only within this middleware. When any error occurs, this function will be called instead of sending it to the router. This is designed for more flexible control. AuthJWT Updates the JWT authentication encoding accordingly with key updates. That is, the update depends directly on the frequency of key updates in GloablFlow. The onErr element is used for error management only within this middleware. When any error occurs, this function will be called instead of sending it to the router. This is designed for more flexible control. A more detailed explanation of the function arguments: Sets the JWT token for further work with it. type SetToken func(w http.ResponseWriter, r *http.Request, manager interfaces.Manager) (string, error) UpdatedToken function, which is called only if the token has been updated. Passes a single updated token. type UpdatedToken func(w http.ResponseWriter, r *http.Request, manager interfaces.Manager, token string, AID int) error Function to which the user id is passed. This function is called each time the [AuthJWT] middleware is triggered. The function works both after token update and without update. type CurrentUID func(w http.ResponseWriter, r *http.Request, manager interfaces.Manager, AID int) error","title":"Auth"},{"location":"builtin/mddl/auth/#auth-middlewares","text":"","title":"auth middlewares"},{"location":"builtin/mddl/auth/#auth","text":"Auth is used to determine when to change the AUTH cookie encoding. When keys are changed, a change date is set. If the date does not match, then you need to change the encoding. It is important to note that only previous keys are saved; accordingly, it is impossible to update the encoding if two or more key iterations have passed, because the old keys are no longer known. This middleware should not work on the login page. Therefore, you need to specify the loginUrl correctly. The onErr element is used for error management only within this middleware. When any error occurs, this function will be called instead of sending it to the router. This is designed for more flexible control.","title":"Auth"},{"location":"builtin/mddl/auth/#authjwt","text":"Updates the JWT authentication encoding accordingly with key updates. That is, the update depends directly on the frequency of key updates in GloablFlow. The onErr element is used for error management only within this middleware. When any error occurs, this function will be called instead of sending it to the router. This is designed for more flexible control. A more detailed explanation of the function arguments: Sets the JWT token for further work with it. type SetToken func(w http.ResponseWriter, r *http.Request, manager interfaces.Manager) (string, error) UpdatedToken function, which is called only if the token has been updated. Passes a single updated token. type UpdatedToken func(w http.ResponseWriter, r *http.Request, manager interfaces.Manager, token string, AID int) error Function to which the user id is passed. This function is called each time the [AuthJWT] middleware is triggered. The function works both after token update and without update. type CurrentUID func(w http.ResponseWriter, r *http.Request, manager interfaces.Manager, AID int) error","title":"AuthJWT"},{"location":"builtin/mddl/csrf/","text":"builtin csrf middlewares GenerateAndSetCsrf A middleware designed to generate a CSRF token. The token is set as a cookie value. To use it you need to run the method in a synchronous or asynchronous handler. maxAge \u2014 cookie lifetime. onError \u2014 a function that will be executed during an error. func GenerateAndSetCsrf(maxAge int, httpOnly bool) middlewares.PreMiddleware { return func(w http.ResponseWriter, r *http.Request, manager interfaces.Manager) error { if err := secure.SetCSRFToken(maxAge, httpOnly, w, r, manager); err != nil { return err } return nil } }","title":"Csrf"},{"location":"builtin/mddl/csrf/#builtin-csrf-middlewares","text":"","title":"builtin csrf middlewares"},{"location":"builtin/mddl/csrf/#generateandsetcsrf","text":"A middleware designed to generate a CSRF token. The token is set as a cookie value. To use it you need to run the method in a synchronous or asynchronous handler. maxAge \u2014 cookie lifetime. onError \u2014 a function that will be executed during an error. func GenerateAndSetCsrf(maxAge int, httpOnly bool) middlewares.PreMiddleware { return func(w http.ResponseWriter, r *http.Request, manager interfaces.Manager) error { if err := secure.SetCSRFToken(maxAge, httpOnly, w, r, manager); err != nil { return err } return nil } }","title":"GenerateAndSetCsrf"},{"location":"cmd_and_config/cmd/","text":"Cmd This package is responsible for the interaction of console commands with the project. It must be initialized by running the Run method. Initialization For initial initialization, you need to create a file such as cmd.go with the following content: package main import \"github.com/uwine4850/foozy/pkg/cmd\" func main() { if err := cmd.Run(); err != nil { panic(err) } } Note : most often, after import the github.com/uwine4850/foozy/pkg/cmd package, you need to run the go mod tidy command. Commands can now be used with the following call: go run cmd.go <command> . Commands Commands that are available in the package. cnf-init \u2014 initializes the configuration settings. The following file(including directory) is generated: init_cnf/init_cnf.go . The file has the following contents: package initcnf import ( \"github.com/uwine4850/foozy/pkg/config\" ) // InitCnf initializes the configuration settings. // This function should be used before initializing cmd(Run() function) // and the server. func InitCnf() { cnf := config.Cnf() // Use this to add your configurations. // cnf.AppendAdditionally(\"my_cnf\", typeopr.Ptr{}.New(&MyCnfCtruct{})) cnf.SetPath(\"cnf/config.yaml\") cnf.SetLoadPath(\"cnf/config.yaml\") } cnf-gen \u2014 generates the config.yaml configuration file. To do this, the following operations must be performed: Call the cnf-init command. Call the InitCnf() function in the previously created cmd.go file. More information about the InitCnf() function is written here . Now the cmd.go file should look like this: package main import ( initcnf \"tee/cnf/init_cnf\" \"github.com/uwine4850/foozy/pkg/cmd\" ) func main() { initcnf.InitCnf() if err := cmd.Run(); err != nil { panic(err) } } cnf-info \u2014 shows information about the configuration file.","title":"Cmd"},{"location":"cmd_and_config/cmd/#cmd","text":"This package is responsible for the interaction of console commands with the project. It must be initialized by running the Run method.","title":"Cmd"},{"location":"cmd_and_config/cmd/#initialization","text":"For initial initialization, you need to create a file such as cmd.go with the following content: package main import \"github.com/uwine4850/foozy/pkg/cmd\" func main() { if err := cmd.Run(); err != nil { panic(err) } } Note : most often, after import the github.com/uwine4850/foozy/pkg/cmd package, you need to run the go mod tidy command. Commands can now be used with the following call: go run cmd.go <command> .","title":"Initialization"},{"location":"cmd_and_config/cmd/#commands","text":"Commands that are available in the package. cnf-init \u2014 initializes the configuration settings. The following file(including directory) is generated: init_cnf/init_cnf.go . The file has the following contents: package initcnf import ( \"github.com/uwine4850/foozy/pkg/config\" ) // InitCnf initializes the configuration settings. // This function should be used before initializing cmd(Run() function) // and the server. func InitCnf() { cnf := config.Cnf() // Use this to add your configurations. // cnf.AppendAdditionally(\"my_cnf\", typeopr.Ptr{}.New(&MyCnfCtruct{})) cnf.SetPath(\"cnf/config.yaml\") cnf.SetLoadPath(\"cnf/config.yaml\") } cnf-gen \u2014 generates the config.yaml configuration file. To do this, the following operations must be performed: Call the cnf-init command. Call the InitCnf() function in the previously created cmd.go file. More information about the InitCnf() function is written here . Now the cmd.go file should look like this: package main import ( initcnf \"tee/cnf/init_cnf\" \"github.com/uwine4850/foozy/pkg/cmd\" ) func main() { initcnf.InitCnf() if err := cmd.Run(); err != nil { panic(err) } } cnf-info \u2014 shows information about the configuration file.","title":"Commands"},{"location":"cmd_and_config/config/","text":"Config This package is designed to create, customize and use a configuration file. The configuration uses the singleton pattern. Also the configuration must be preloaded using the generated InitCnf() function. This function does not need to be called more than once per session. NOTE: after changing the configuration, you must reboot the server. This package is divided into three sections: Representing the configuration as a golang object Generating a configuration file Loading the configuration file You can read more about each section below. Representing the configuration as a golang object The Config object is used for the global representation of the configuration. The object stores configuration data, is used for generation and stores loaded data from config.yaml . type Config struct { GeneratedDefault bool `yaml:\"GeneratedDefault\"` GeneratedAdditionally bool `yaml:\"GeneratedAdditionally\"` Default DefaultConfig `yaml:\"Config\"` Additionally map[string]interface{} `yaml:\"Additionally\"` path string loadPath string } The GeneratedDefault and GeneratedAdditionally fields are intended to avoid re-generating the config and thus resetting the settings. If you still need to reset the settings, these fields should be set to false in the config.yaml file. The Default field is responsible for the standard configuration of the framework. The Additionally field is for custom settings. That is, the user can put his own configs in this field and change them in the common config.yaml file. This should be done right here using the AppendAdditionally method: func InitCnf() { cnf := config.Cnf() // Use this to add your configurations. // cnf.AppendAdditionally(\"my_cnf\", typeopr.Ptr{}.New(&MyCnfCtruct{})) cnf.SetPath(\"cnf/config.yaml\") cnf.SetLoadPath(\"cnf/config.yaml\") } The path and loadPath fields should contain the path to the generated configuration file. More precisely: path - the place of configuration generation, loadPath - the place of configuration loading. Two fields are made because the paths may differ syntactically, e.g. \"config.yaml\" and \"../config.yaml\". The Cnf function is a singleton for accessing configuration settings. This function has nothing to do with outputting the configuration from the config.yaml file, it only provides access to the configuration generation settings. To just get the default configuration template you need to call this function. NOTE: this function should not be confused with LoadedConfig as it gives the same object but it does not store the actual project settings. func Cnf() *Config Configuration templates All configuration templates are shown below. They will be used to generate the standard config.yaml . This is also an example of how the configuration passed to the AppendAdditionally method should look like. Two structural tags will also be used here: yaml - field name. i - brief information about the field. The DefaultConfig object is a master template that contains all additional configuration templates. type DefaultConfig struct { Debug DebugConfig `yaml:\"Debug\"` Database DatabaseConfig `yaml:\"Database\"` } The DebugConfig object is the debug settings. type DebugConfig struct { PrintInfo bool `yaml:\"PrintInfo\" i:\"Displays basic information about each request.\"` Debug bool `yaml:\"Debug\" i:\"Enables debugging\"` DebugRelativeFilepath bool `yaml:\"DebugRelativeFilepath\" i:\"In logs, file paths are displayed relatively\"` ErrorLogging bool `yaml:\"ErrorLogging\" i:\"Enables error logging\"` ErrorLoggingPath string `yaml:\"ErrorLoggingPath\" i:\"Path to error log file\"` RequestInfoLog bool `yaml:\"RequestInfoLog\" i:\"Enables request logging\"` RequestInfoLogPath string `yaml:\"RequestInfoLogPath\" i:\"Path to request log file\"` SkipLoggingLevel int `yaml:\"SkipLoggingLevel\" i:\"Skips logging levels. May need to be configured per project\"` } The DatabaseConfig object is a part of the database configuration. The rest of the settings can be found directly in the TODO: add link corresponding package . type DatabaseConfig struct { MainConnectionPoolName string `yaml:\"MainConnectionPoolName\" i:\"The name of the main connection pool\"` } Info The Info function displays all information about the configuration fields that have the i tag. func Info() Generating a configuration file There is only one Generate object in this section. It is used only for generating the config.yaml configuration file. For correct operation it is necessary to use the Config object. A config.yaml file will be generated based on it. In the standard implementation, the config.Cnf() method must be used to get the Config object. It can be configured in advance. Config.Gen Method Gen generates a configuration file. The previously installed Config object is used for generation. Before generation, the previous config file is loaded, if it exists. When the configuration file exists, the following actions are performed: If the GeneratedDefault field is true, the default config will not be overwritten in the Config file If GeneratedAdditionally is true, the optional configuration is not overwritten, but if there are new or deleted fields, such changes will take effect. func (g *Generate) Gen() error InitCnf The InitCnf function is designed to initialize the nonfiguration. It currently does two things: Setting paths to configuration files. Adding a custom configuration via the AppendAdditionally method. Therefore, this function must be called at least once per session in order to know where to load the configuration and also to load the user data. func InitCnf() { cnf := config.Cnf() // Use this to add your configurations. // cnf.AppendAdditionally(\"my_cnf\", typeopr.Ptr{}.New(&MyCnfCtruct{})) cnf.SetPath(\"cnf/config.yaml\") cnf.SetLoadPath(\"cnf/config.yaml\") } Loading the configuration file This part of the package is designed to load a sonfiguration from the config.yaml file and retrieve the loaded configuration. Load Function Load loads the settings from the config.yaml file. The file is loaded by the path(loadPath) , which is configured with the Config object. In addition, the configurations are loaded into a new instance of the Config structure. Due to the fact that the field Additionally has type map[string]interface{} type interface{} needs to be converted into a structure. func Load() (*Config, error) LoadedConfig Function LoadedConfig singleton that loads the settings. It is preferable to use this function rather than Load to avoid loading the config every time. It is important to specify that changes in config.yaml settings are not taken into account after the framework is started, so it is necessary to restart the server after changing the configuration. func LoadedConfig() *Config","title":"Config"},{"location":"cmd_and_config/config/#config","text":"This package is designed to create, customize and use a configuration file. The configuration uses the singleton pattern. Also the configuration must be preloaded using the generated InitCnf() function. This function does not need to be called more than once per session. NOTE: after changing the configuration, you must reboot the server. This package is divided into three sections: Representing the configuration as a golang object Generating a configuration file Loading the configuration file You can read more about each section below.","title":"Config"},{"location":"cmd_and_config/config/#representing-the-configuration-as-a-golang-object","text":"The Config object is used for the global representation of the configuration. The object stores configuration data, is used for generation and stores loaded data from config.yaml . type Config struct { GeneratedDefault bool `yaml:\"GeneratedDefault\"` GeneratedAdditionally bool `yaml:\"GeneratedAdditionally\"` Default DefaultConfig `yaml:\"Config\"` Additionally map[string]interface{} `yaml:\"Additionally\"` path string loadPath string } The GeneratedDefault and GeneratedAdditionally fields are intended to avoid re-generating the config and thus resetting the settings. If you still need to reset the settings, these fields should be set to false in the config.yaml file. The Default field is responsible for the standard configuration of the framework. The Additionally field is for custom settings. That is, the user can put his own configs in this field and change them in the common config.yaml file. This should be done right here using the AppendAdditionally method: func InitCnf() { cnf := config.Cnf() // Use this to add your configurations. // cnf.AppendAdditionally(\"my_cnf\", typeopr.Ptr{}.New(&MyCnfCtruct{})) cnf.SetPath(\"cnf/config.yaml\") cnf.SetLoadPath(\"cnf/config.yaml\") } The path and loadPath fields should contain the path to the generated configuration file. More precisely: path - the place of configuration generation, loadPath - the place of configuration loading. Two fields are made because the paths may differ syntactically, e.g. \"config.yaml\" and \"../config.yaml\". The Cnf function is a singleton for accessing configuration settings. This function has nothing to do with outputting the configuration from the config.yaml file, it only provides access to the configuration generation settings. To just get the default configuration template you need to call this function. NOTE: this function should not be confused with LoadedConfig as it gives the same object but it does not store the actual project settings. func Cnf() *Config","title":"Representing the configuration as a golang object"},{"location":"cmd_and_config/config/#configuration-templates","text":"All configuration templates are shown below. They will be used to generate the standard config.yaml . This is also an example of how the configuration passed to the AppendAdditionally method should look like. Two structural tags will also be used here: yaml - field name. i - brief information about the field. The DefaultConfig object is a master template that contains all additional configuration templates. type DefaultConfig struct { Debug DebugConfig `yaml:\"Debug\"` Database DatabaseConfig `yaml:\"Database\"` } The DebugConfig object is the debug settings. type DebugConfig struct { PrintInfo bool `yaml:\"PrintInfo\" i:\"Displays basic information about each request.\"` Debug bool `yaml:\"Debug\" i:\"Enables debugging\"` DebugRelativeFilepath bool `yaml:\"DebugRelativeFilepath\" i:\"In logs, file paths are displayed relatively\"` ErrorLogging bool `yaml:\"ErrorLogging\" i:\"Enables error logging\"` ErrorLoggingPath string `yaml:\"ErrorLoggingPath\" i:\"Path to error log file\"` RequestInfoLog bool `yaml:\"RequestInfoLog\" i:\"Enables request logging\"` RequestInfoLogPath string `yaml:\"RequestInfoLogPath\" i:\"Path to request log file\"` SkipLoggingLevel int `yaml:\"SkipLoggingLevel\" i:\"Skips logging levels. May need to be configured per project\"` } The DatabaseConfig object is a part of the database configuration. The rest of the settings can be found directly in the TODO: add link corresponding package . type DatabaseConfig struct { MainConnectionPoolName string `yaml:\"MainConnectionPoolName\" i:\"The name of the main connection pool\"` }","title":"Configuration templates"},{"location":"cmd_and_config/config/#info","text":"The Info function displays all information about the configuration fields that have the i tag. func Info()","title":"Info"},{"location":"cmd_and_config/config/#generating-a-configuration-file","text":"There is only one Generate object in this section. It is used only for generating the config.yaml configuration file. For correct operation it is necessary to use the Config object. A config.yaml file will be generated based on it. In the standard implementation, the config.Cnf() method must be used to get the Config object. It can be configured in advance.","title":"Generating a configuration file"},{"location":"cmd_and_config/config/#configgen","text":"Method Gen generates a configuration file. The previously installed Config object is used for generation. Before generation, the previous config file is loaded, if it exists. When the configuration file exists, the following actions are performed: If the GeneratedDefault field is true, the default config will not be overwritten in the Config file If GeneratedAdditionally is true, the optional configuration is not overwritten, but if there are new or deleted fields, such changes will take effect. func (g *Generate) Gen() error","title":"Config.Gen"},{"location":"cmd_and_config/config/#initcnf","text":"The InitCnf function is designed to initialize the nonfiguration. It currently does two things: Setting paths to configuration files. Adding a custom configuration via the AppendAdditionally method. Therefore, this function must be called at least once per session in order to know where to load the configuration and also to load the user data. func InitCnf() { cnf := config.Cnf() // Use this to add your configurations. // cnf.AppendAdditionally(\"my_cnf\", typeopr.Ptr{}.New(&MyCnfCtruct{})) cnf.SetPath(\"cnf/config.yaml\") cnf.SetLoadPath(\"cnf/config.yaml\") }","title":"InitCnf"},{"location":"cmd_and_config/config/#loading-the-configuration-file","text":"This part of the package is designed to load a sonfiguration from the config.yaml file and retrieve the loaded configuration.","title":"Loading the configuration file"},{"location":"cmd_and_config/config/#load","text":"Function Load loads the settings from the config.yaml file. The file is loaded by the path(loadPath) , which is configured with the Config object. In addition, the configurations are loaded into a new instance of the Config structure. Due to the fact that the field Additionally has type map[string]interface{} type interface{} needs to be converted into a structure. func Load() (*Config, error)","title":"Load"},{"location":"cmd_and_config/config/#loadedconfig","text":"Function LoadedConfig singleton that loads the settings. It is preferable to use this function rather than Load to avoid loading the config every time. It is important to specify that changes in config.yaml settings are not taken into account after the framework is started, so it is necessary to restart the server after changing the configuration. func LoadedConfig() *Config","title":"LoadedConfig"},{"location":"codegen/gen/","text":"Codegen Generating a file with code. Generate Generates files from a defined path. The map key \u2014 path to the directory where the file will be. Map value \u2014 path to the file to be generated. func Generate(data map[string]string) error { for dirpath, targetFilepath := range data { targetFile, err := os.Open(targetFilepath) if err != nil { return err } defer targetFile.Close() fullNewPath := filepath.Join(dirpath, filepath.Base(targetFilepath)) if err := os.MkdirAll(dirpath, os.ModePerm); err != nil { return err } newFile, err := os.Create(fullNewPath) if err != nil { return err } defer newFile.Close() _, err = io.Copy(newFile, targetFile) if err != nil { return err } } return nil }","title":"Gen"},{"location":"codegen/gen/#codegen","text":"Generating a file with code.","title":"Codegen"},{"location":"codegen/gen/#generate","text":"Generates files from a defined path. The map key \u2014 path to the directory where the file will be. Map value \u2014 path to the file to be generated. func Generate(data map[string]string) error { for dirpath, targetFilepath := range data { targetFile, err := os.Open(targetFilepath) if err != nil { return err } defer targetFile.Close() fullNewPath := filepath.Join(dirpath, filepath.Base(targetFilepath)) if err := os.MkdirAll(dirpath, os.ModePerm); err != nil { return err } newFile, err := os.Create(fullNewPath) if err != nil { return err } defer newFile.Close() _, err = io.Copy(newFile, targetFile) if err != nil { return err } } return nil }","title":"Generate"},{"location":"database/async_queries/","text":"database AsyncQueries asynchronous database queries. The ISyncQueries is used to implement the queries, only it is wrapped in this object. For each query, you must specify a key by which it can be identified. IMPORTANT_1 : it is necessary to call [Wait] method to correctly wait for queries execution. IMPORTANT_2 : for each new asynchronous request you must create a separate instance of this object. This is done to protect the user from data leakage, because the object saves user request data and should not be shared. type AsyncQueries struct { syncQ interfaces.SyncQ wg sync.WaitGroup asyncRes sync.Map } AsyncQueries.LoadAsyncRes Retrieves command execution data by key. func (q *AsyncQueries) LoadAsyncRes(key string) (*dbutils.AsyncQueryData, bool) { value, ok := q.asyncRes.Load(key) if ok { v := value.(*dbutils.AsyncQueryData) return v, ok } return nil, ok } AsyncQueries.Wait Waits for the execution of all asynchronous methods that are started before executing this method. IMPORTANT : this method must be run before LoadAsyncRes. Several Wait methods can be called if necessary. func (q *AsyncQueries) Wait() { q.wg.Wait() } AsyncQueries.Clear Clears the query results data. func (q *AsyncQueries) Clear() { q.asyncRes = sync.Map{} } AsyncQueries.AsyncResError Loads the result of several asynchronous key queries and checks for errors. func AsyncResError(keys []string, asyncQ interfaces.AsyncQ) error { for i := 0; i < len(keys); i++ { res, ok := asyncQ.LoadAsyncRes(keys[i]) if !ok { return errors.New(\"key for loading the result of asynchronous query not found\") } if res.Error != nil { return res.Error } } return nil }","title":"AsyncQueries"},{"location":"database/async_queries/#database","text":"","title":"database"},{"location":"database/async_queries/#asyncqueries","text":"asynchronous database queries. The ISyncQueries is used to implement the queries, only it is wrapped in this object. For each query, you must specify a key by which it can be identified. IMPORTANT_1 : it is necessary to call [Wait] method to correctly wait for queries execution. IMPORTANT_2 : for each new asynchronous request you must create a separate instance of this object. This is done to protect the user from data leakage, because the object saves user request data and should not be shared. type AsyncQueries struct { syncQ interfaces.SyncQ wg sync.WaitGroup asyncRes sync.Map }","title":"AsyncQueries"},{"location":"database/async_queries/#asyncqueriesloadasyncres","text":"Retrieves command execution data by key. func (q *AsyncQueries) LoadAsyncRes(key string) (*dbutils.AsyncQueryData, bool) { value, ok := q.asyncRes.Load(key) if ok { v := value.(*dbutils.AsyncQueryData) return v, ok } return nil, ok }","title":"AsyncQueries.LoadAsyncRes"},{"location":"database/async_queries/#asyncquerieswait","text":"Waits for the execution of all asynchronous methods that are started before executing this method. IMPORTANT : this method must be run before LoadAsyncRes. Several Wait methods can be called if necessary. func (q *AsyncQueries) Wait() { q.wg.Wait() }","title":"AsyncQueries.Wait"},{"location":"database/async_queries/#asyncqueriesclear","text":"Clears the query results data. func (q *AsyncQueries) Clear() { q.asyncRes = sync.Map{} }","title":"AsyncQueries.Clear"},{"location":"database/async_queries/#asyncqueriesasyncreserror","text":"Loads the result of several asynchronous key queries and checks for errors. func AsyncResError(keys []string, asyncQ interfaces.AsyncQ) error { for i := 0; i < len(keys); i++ { res, ok := asyncQ.LoadAsyncRes(keys[i]) if !ok { return errors.New(\"key for loading the result of asynchronous query not found\") } if res.Error != nil { return res.Error } } return nil }","title":"AsyncQueries.AsyncResError"},{"location":"database/database/","text":"database Implementation of Mysql database interfaces. MysqlDatabase Implementation of Database , SyncAsyncQuery and DatabaseInteraction interfaces. Object for accessing the database. It can send both synchronous and asynchronous queries. IMPORTANT : after the end of work it is necessary to close the connection using Close method. For each transaction a new instance of the Transaction object is created, so each transaction is executed in its own scope and is completely safe. type MysqlDatabase struct { username string password string host string port string database string db *sql.DB tx *sql.Tx syncQ interfaces.SyncQ asyncQ interfaces.AsyncQ } MysqlDatabase.Open Connecting to a mysql database. Also, initialization of synchronous and asynchronous queries. func (d *MysqlDatabase) Open() error { connStr := fmt.Sprintf(\"%s:%s@tcp(%s:%s)/%s\", d.username, d.password, d.host, d.port, d.database) db, err := sql.Open(\"mysql\", connStr) if err != nil { return err } err = db.Ping() if err != nil { return err } d.db = db d.syncQ.SetDB(&DbQuery{DB: db}) return nil } MysqlDatabase.Close Closes the connection to the database. func (d *MysqlDatabase) Close() error { err := d.db.Close() if err != nil { return err } if d.tx != nil { if err := d.tx.Rollback(); err != nil { return err } d.tx = nil } return nil } MysqlDatabase.NewTransaction func (d *MysqlDatabase) NewTransaction() (interfaces.DatabaseTransaction, error) { return NewMysqlTransaction(d.db, d.syncQ, d.asyncQ) } MysqlDatabase.SyncQ Getting access to synchronous requests. func (d *MysqlDatabase) SyncQ() interfaces.SyncQ { return d.syncQ } MysqlDatabase.NewAsyncQ Creates and returns a new instance of interfaces.AsyncQ . This is necessary for data security, since interfaces.AsyncQ stores SQL query data, so a separate instance must be created for each HTTP handler. func (d *MysqlDatabase) NewAsyncQ() (interfaces.AsyncQ, error) { aq, err := d.asyncQ.New() if err != nil { return nil, err } return aq.(interfaces.AsyncQ), nil } MysqlTransaction An object that performs transactions to the mysql database. This object is used only for one transaction, for each next transaction a new instance of the object must be created. type MysqlTransaction struct { db *sql.DB tx *sql.Tx syncQ interfaces.SyncQ asyncQ interfaces.AsyncQ } MysqlTransaction.BeginTransaction Starts the transaction. Only one transaction can be started per object instance. func (t *MysqlTransaction) BeginTransaction() error { if t.tx != nil { return errors.New(\"transaction already started\") } tx, err := t.db.Begin() if err != nil { return err } t.syncQ.SetDB(&DbTxQuery{Tx: tx}) t.asyncQ.SetSyncQueries(t.syncQ) t.tx = tx return nil } MysqlTransaction.CommitTransaction Writes the transaction to the database. func (t *MysqlTransaction) CommitTransaction() error { if t.tx == nil { return errors.New(\"transaction not begin\") } if err := t.tx.Commit(); err != nil { return err } t.tx = nil return nil } MysqlTransaction.RollBackTransaction Undoes any changes that were made during the transaction. That is, after executing the BeginTransaction method. func (t *MysqlTransaction) RollBackTransaction() error { if t.tx == nil { return errors.New(\"transaction not begin\") } if err := t.tx.Rollback(); err != nil { return err } t.tx = nil return nil } MysqlTransaction.SyncQ Getting access to synchronous requests. func (t *MysqlTransaction) SyncQ() interfaces.SyncQ { return t.syncQ } MysqlTransaction.NewAsyncQ Creates and returns a new instance of interfaces.AsyncQ . This is necessary for data security, since interfaces.AsyncQ stores SQL query data, so a separate instance must be created for each HTTP handler. func (t *MysqlTransaction) NewAsyncQ() (interfaces.AsyncQ, error) { aq, err := t.asyncQ.New() if err != nil { return nil, err } return aq.(interfaces.AsyncQ), nil } DbQuery Standard database queries. They are used *sql.DB. Requests are executed as usual. type DbQuery struct { DB *sql.DB } DbQuery.Query Used to execute queries that return data. For example, the SELECT command. func (d *DbQuery) Query(query string, args ...any) ([]map[string]interface{}, error) { sqlRows, err := d.DB.Query(query, args...) if err != nil { return nil, err } rows, err := scanRows(sqlRows) if err != nil { return nil, err } err = sqlRows.Close() if err != nil { return nil, err } return rows, nil } DbQuery.Exec Used to execute queries that do not return data. For example, the INSERT command. Returns the following data: Key \"insertID\" is the identifier of the inserted row using INSERT. Key \"rowsAffected\" - Returns the number of rows affected by INSERT, UPDATE, DELETE. func (d *DbQuery) Exec(query string, args ...any) (map[string]interface{}, error) { result, err := d.DB.Exec(query, args...) if err != nil { return nil, err } id, err := result.LastInsertId() if err != nil { return nil, err } rowsId, err := result.RowsAffected() if err != nil { return nil, err } return map[string]interface{}{\"insertID\": id, \"rowsAffected\": rowsId}, nil } DbTxQuery Queries that can be rolled back. Used *sql.Tx. This object will perform queries with the *sql.Tx object that is used for transactions. type DbTxQuery struct { Tx *sql.Tx } DbTxQuery.Query Used to execute queries that return data. For example, the SELECT command. func (d *DbTxQuery) Query(query string, args ...any) ([]map[string]interface{}, error) { sqlRows, err := d.Tx.Query(query, args...) if err != nil { return nil, err } rows, err := scanRows(sqlRows) if err != nil { return nil, err } err = sqlRows.Close() if err != nil { return nil, err } return rows, nil } DbTxQuery.Exec Used to execute queries that do not return data. For example, the INSERT command. Returns the following data: Key \"insertID\" is the identifier of the inserted row using INSERT. Key \"rowsAffected\" - Returns the number of rows affected by INSERT, UPDATE, DELETE. func (d *DbTxQuery) Exec(query string, args ...any) (map[string]interface{}, error) { result, err := d.Tx.Exec(query, args...) if err != nil { return nil, err } id, err := result.LastInsertId() if err != nil { return nil, err } rowsId, err := result.RowsAffected() if err != nil { return nil, err } return map[string]interface{}{\"id\": id, \"rows\": rowsId}, nil } InitDatabasePool Initializes a database pool. Only one pool is created, which is specified in the Default.Database.MainConnectionPoolName settings. Once created, the pool is locked. Therefore, you need to initialize it manually if you need more connections. func InitDatabasePool(manager interfaces.Manager, db interfaces.Database) error { name := config.LoadedConfig().Default.Database.MainConnectionPoolName if err := manager.Database().AddConnection(name, db); err != nil { return err } manager.Database().Lock() return nil }","title":"Database"},{"location":"database/database/#database","text":"Implementation of Mysql database interfaces.","title":"database"},{"location":"database/database/#mysqldatabase","text":"Implementation of Database , SyncAsyncQuery and DatabaseInteraction interfaces. Object for accessing the database. It can send both synchronous and asynchronous queries. IMPORTANT : after the end of work it is necessary to close the connection using Close method. For each transaction a new instance of the Transaction object is created, so each transaction is executed in its own scope and is completely safe. type MysqlDatabase struct { username string password string host string port string database string db *sql.DB tx *sql.Tx syncQ interfaces.SyncQ asyncQ interfaces.AsyncQ }","title":"MysqlDatabase"},{"location":"database/database/#mysqldatabaseopen","text":"Connecting to a mysql database. Also, initialization of synchronous and asynchronous queries. func (d *MysqlDatabase) Open() error { connStr := fmt.Sprintf(\"%s:%s@tcp(%s:%s)/%s\", d.username, d.password, d.host, d.port, d.database) db, err := sql.Open(\"mysql\", connStr) if err != nil { return err } err = db.Ping() if err != nil { return err } d.db = db d.syncQ.SetDB(&DbQuery{DB: db}) return nil }","title":"MysqlDatabase.Open"},{"location":"database/database/#mysqldatabaseclose","text":"Closes the connection to the database. func (d *MysqlDatabase) Close() error { err := d.db.Close() if err != nil { return err } if d.tx != nil { if err := d.tx.Rollback(); err != nil { return err } d.tx = nil } return nil }","title":"MysqlDatabase.Close"},{"location":"database/database/#mysqldatabasenewtransaction","text":"func (d *MysqlDatabase) NewTransaction() (interfaces.DatabaseTransaction, error) { return NewMysqlTransaction(d.db, d.syncQ, d.asyncQ) }","title":"MysqlDatabase.NewTransaction"},{"location":"database/database/#mysqldatabasesyncq","text":"Getting access to synchronous requests. func (d *MysqlDatabase) SyncQ() interfaces.SyncQ { return d.syncQ }","title":"MysqlDatabase.SyncQ"},{"location":"database/database/#mysqldatabasenewasyncq","text":"Creates and returns a new instance of interfaces.AsyncQ . This is necessary for data security, since interfaces.AsyncQ stores SQL query data, so a separate instance must be created for each HTTP handler. func (d *MysqlDatabase) NewAsyncQ() (interfaces.AsyncQ, error) { aq, err := d.asyncQ.New() if err != nil { return nil, err } return aq.(interfaces.AsyncQ), nil }","title":"MysqlDatabase.NewAsyncQ"},{"location":"database/database/#mysqltransaction","text":"An object that performs transactions to the mysql database. This object is used only for one transaction, for each next transaction a new instance of the object must be created. type MysqlTransaction struct { db *sql.DB tx *sql.Tx syncQ interfaces.SyncQ asyncQ interfaces.AsyncQ }","title":"MysqlTransaction"},{"location":"database/database/#mysqltransactionbegintransaction","text":"Starts the transaction. Only one transaction can be started per object instance. func (t *MysqlTransaction) BeginTransaction() error { if t.tx != nil { return errors.New(\"transaction already started\") } tx, err := t.db.Begin() if err != nil { return err } t.syncQ.SetDB(&DbTxQuery{Tx: tx}) t.asyncQ.SetSyncQueries(t.syncQ) t.tx = tx return nil }","title":"MysqlTransaction.BeginTransaction"},{"location":"database/database/#mysqltransactioncommittransaction","text":"Writes the transaction to the database. func (t *MysqlTransaction) CommitTransaction() error { if t.tx == nil { return errors.New(\"transaction not begin\") } if err := t.tx.Commit(); err != nil { return err } t.tx = nil return nil }","title":"MysqlTransaction.CommitTransaction"},{"location":"database/database/#mysqltransactionrollbacktransaction","text":"Undoes any changes that were made during the transaction. That is, after executing the BeginTransaction method. func (t *MysqlTransaction) RollBackTransaction() error { if t.tx == nil { return errors.New(\"transaction not begin\") } if err := t.tx.Rollback(); err != nil { return err } t.tx = nil return nil }","title":"MysqlTransaction.RollBackTransaction"},{"location":"database/database/#mysqltransactionsyncq","text":"Getting access to synchronous requests. func (t *MysqlTransaction) SyncQ() interfaces.SyncQ { return t.syncQ }","title":"MysqlTransaction.SyncQ"},{"location":"database/database/#mysqltransactionnewasyncq","text":"Creates and returns a new instance of interfaces.AsyncQ . This is necessary for data security, since interfaces.AsyncQ stores SQL query data, so a separate instance must be created for each HTTP handler. func (t *MysqlTransaction) NewAsyncQ() (interfaces.AsyncQ, error) { aq, err := t.asyncQ.New() if err != nil { return nil, err } return aq.(interfaces.AsyncQ), nil }","title":"MysqlTransaction.NewAsyncQ"},{"location":"database/database/#dbquery","text":"Standard database queries. They are used *sql.DB. Requests are executed as usual. type DbQuery struct { DB *sql.DB }","title":"DbQuery"},{"location":"database/database/#dbqueryquery","text":"Used to execute queries that return data. For example, the SELECT command. func (d *DbQuery) Query(query string, args ...any) ([]map[string]interface{}, error) { sqlRows, err := d.DB.Query(query, args...) if err != nil { return nil, err } rows, err := scanRows(sqlRows) if err != nil { return nil, err } err = sqlRows.Close() if err != nil { return nil, err } return rows, nil }","title":"DbQuery.Query"},{"location":"database/database/#dbqueryexec","text":"Used to execute queries that do not return data. For example, the INSERT command. Returns the following data: Key \"insertID\" is the identifier of the inserted row using INSERT. Key \"rowsAffected\" - Returns the number of rows affected by INSERT, UPDATE, DELETE. func (d *DbQuery) Exec(query string, args ...any) (map[string]interface{}, error) { result, err := d.DB.Exec(query, args...) if err != nil { return nil, err } id, err := result.LastInsertId() if err != nil { return nil, err } rowsId, err := result.RowsAffected() if err != nil { return nil, err } return map[string]interface{}{\"insertID\": id, \"rowsAffected\": rowsId}, nil }","title":"DbQuery.Exec"},{"location":"database/database/#dbtxquery","text":"Queries that can be rolled back. Used *sql.Tx. This object will perform queries with the *sql.Tx object that is used for transactions. type DbTxQuery struct { Tx *sql.Tx }","title":"DbTxQuery"},{"location":"database/database/#dbtxqueryquery","text":"Used to execute queries that return data. For example, the SELECT command. func (d *DbTxQuery) Query(query string, args ...any) ([]map[string]interface{}, error) { sqlRows, err := d.Tx.Query(query, args...) if err != nil { return nil, err } rows, err := scanRows(sqlRows) if err != nil { return nil, err } err = sqlRows.Close() if err != nil { return nil, err } return rows, nil }","title":"DbTxQuery.Query"},{"location":"database/database/#dbtxqueryexec","text":"Used to execute queries that do not return data. For example, the INSERT command. Returns the following data: Key \"insertID\" is the identifier of the inserted row using INSERT. Key \"rowsAffected\" - Returns the number of rows affected by INSERT, UPDATE, DELETE. func (d *DbTxQuery) Exec(query string, args ...any) (map[string]interface{}, error) { result, err := d.Tx.Exec(query, args...) if err != nil { return nil, err } id, err := result.LastInsertId() if err != nil { return nil, err } rowsId, err := result.RowsAffected() if err != nil { return nil, err } return map[string]interface{}{\"id\": id, \"rows\": rowsId}, nil }","title":"DbTxQuery.Exec"},{"location":"database/database/#initdatabasepool","text":"Initializes a database pool. Only one pool is created, which is specified in the Default.Database.MainConnectionPoolName settings. Once created, the pool is locked. Therefore, you need to initialize it manually if you need more connections. func InitDatabasePool(manager interfaces.Manager, db interfaces.Database) error { name := config.LoadedConfig().Default.Database.MainConnectionPoolName if err := manager.Database().AddConnection(name, db); err != nil { return err } manager.Database().Lock() return nil }","title":"InitDatabasePool"},{"location":"database/database_pool/","text":"database DatabasePool stores a pool of database connections. To work properly, you need to connect to the database using the Open method and pass the open connection to the ConnectionPool method. There can be several connections, but usually one connection pool is enough. After all the settings you need to call the Lock method to lock all the changes. After calling this method you can no longer add connections to the pool. Thus, the connection pool remains static and predictable from the beginning to the end of the application. type DatabasePool struct { // Type map[string]interfaces.IReadDatabase. connnectionPool sync.Map locked atomic.Bool } DatabasePool.ConnectionPool Get a named connection pool. func (dp *DatabasePool) ConnectionPool(name string) (interfaces.DatabaseInteraction, error) { if !dp.locked.Load() { return nil, &ErrDatabasePoolNotLocked{} } if val, ok := dp.connnectionPool.Load(name); ok { return val.(interfaces.DatabaseInteraction), nil } else { return nil, &ErrConnectionNotExists{Name: name} } } DatabasePool.AddConnection Adding a new open named database connection pool. func (dp *DatabasePool) AddConnection(name string, dbInteraction interfaces.DatabaseInteraction) error { if dp.locked.Load() { return &ErrDatabasePoolIsLocked{} } if _, ok := dp.connnectionPool.Load(name); ok { return &ErrConnectionAlreadyExists{Name: name} } else { dp.connnectionPool.Store(name, dbInteraction) return nil } } DatabasePool.Lock Blocks further changes to the pool. func (dp *DatabasePool) Lock() { dp.locked.Store(true) }","title":"DatabasePool"},{"location":"database/database_pool/#database","text":"","title":"database"},{"location":"database/database_pool/#databasepool","text":"stores a pool of database connections. To work properly, you need to connect to the database using the Open method and pass the open connection to the ConnectionPool method. There can be several connections, but usually one connection pool is enough. After all the settings you need to call the Lock method to lock all the changes. After calling this method you can no longer add connections to the pool. Thus, the connection pool remains static and predictable from the beginning to the end of the application. type DatabasePool struct { // Type map[string]interfaces.IReadDatabase. connnectionPool sync.Map locked atomic.Bool }","title":"DatabasePool"},{"location":"database/database_pool/#databasepoolconnectionpool","text":"Get a named connection pool. func (dp *DatabasePool) ConnectionPool(name string) (interfaces.DatabaseInteraction, error) { if !dp.locked.Load() { return nil, &ErrDatabasePoolNotLocked{} } if val, ok := dp.connnectionPool.Load(name); ok { return val.(interfaces.DatabaseInteraction), nil } else { return nil, &ErrConnectionNotExists{Name: name} } }","title":"DatabasePool.ConnectionPool"},{"location":"database/database_pool/#databasepooladdconnection","text":"Adding a new open named database connection pool. func (dp *DatabasePool) AddConnection(name string, dbInteraction interfaces.DatabaseInteraction) error { if dp.locked.Load() { return &ErrDatabasePoolIsLocked{} } if _, ok := dp.connnectionPool.Load(name); ok { return &ErrConnectionAlreadyExists{Name: name} } else { dp.connnectionPool.Store(name, dbInteraction) return nil } }","title":"DatabasePool.AddConnection"},{"location":"database/database_pool/#databasepoollock","text":"Blocks further changes to the pool. func (dp *DatabasePool) Lock() { dp.locked.Store(true) }","title":"DatabasePool.Lock"},{"location":"database/sync_queries/","text":"database SyncQueries Sends synchronous SQL queries. type SyncQueries struct { qe interfaces.QueryExec }","title":"SyncQueries"},{"location":"database/sync_queries/#database","text":"","title":"database"},{"location":"database/sync_queries/#syncqueries","text":"Sends synchronous SQL queries. type SyncQueries struct { qe interfaces.QueryExec }","title":"SyncQueries"},{"location":"debug/logging/","text":"Debug This package contains tools for debugging. WriteLog WriteLog writes the message to a log file. skipLevel - skips levels of runtime.Caller. This is used to output the path on which the log is written. filePath - path to the log file. flag - flags for opening a file from the os package. prefix - prefix that will be shown in the log. It is desirable to use constants \u201cP_...\u201d from this package. message - the message that will be recorded. func WriteLog(skipLevel int, filePath string, flag int, prefix string, message string, logFlags int) { var _logFlags int if logFlags == -1 { _logFlags = log.LstdFlags } f, err := os.OpenFile(filePath, flag, 0666) if err != nil { fmt.Println(\"LogError: \", err.Error()) return } defer func(f *os.File) { err := f.Close() if err != nil { fmt.Println(\"LogError: \", err.Error()) return } }(f) ilog := log.New(f, fmt.Sprintf(\"[%s] \", prefix), _logFlags) ilog.SetFlags(_logFlags) if skipLevel < 0 { skipLevel = 3 } _, file, line, ok := runtime.Caller(skipLevel) if !ok { ilog.Println(\"Could not retrieve caller information\") return } loggingFilePath := file if config.LoadedConfig().Default.Debug.DebugRelativeFilepath { wd, err := os.Getwd() if err != nil { ilog.Println(\"Could not retrieve working directory:\", err) return } relPath, err := filepath.Rel(wd, file) if err != nil { ilog.Println(\"Could not calculate relative path:\", err) return } loggingFilePath = relPath } ilog.Printf(\"%s:%d %s\\n\", loggingFilePath, line, message) } LogError Logs errors to the error log. func LogError(message string) { if config.LoadedConfig().Default.Debug.ErrorLoggingPath == \"\" { panic(\"unable to create log file. File path not set\") } WriteLog( config.LoadedConfig().Default.Debug.SkipLoggingLevel+1, config.LoadedConfig().Default.Debug.ErrorLoggingPath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, \"\", message, -1, ) } ErrorLoggingIfEnableAndWrite Writes a message to the log if error logging is enabled. This function also writes a message to the browser page. It is convenient for displaying the error on the page. func ErrorLoggingIfEnableAndWrite(w http.ResponseWriter, errorText string, writeText string) { _, err := w.Write([]byte(writeText)) if err != nil { if config.LoadedConfig().Default.Debug.ErrorLogging { LogError(err.Error()) } } if config.LoadedConfig().Default.Debug.ErrorLogging { LogError(string(errorText)) } } ErrorLogginIfEnable Writes a message to the log if error logging is enabled. func ErrorLogginIfEnable(message string) { if config.LoadedConfig().Default.Debug.ErrorLogging { LogError(message) } } ClearRequestInfoLogging Clears the request log. func ClearRequestInfoLogging() error { if config.LoadedConfig().Default.Debug.RequestInfoLogPath != \"\" && fpath.PathExist(config.LoadedConfig().Default.Debug.RequestInfoLogPath) { f, err := os.OpenFile(config.LoadedConfig().Default.Debug.RequestInfoLogPath, os.O_WRONLY, 0644) if err != nil { return err } defer f.Close() if err := f.Truncate(0); err != nil { return err } } return nil } LogRequestInfo Logs information about the request. func LogRequestInfo(prefix string, message string) { if config.LoadedConfig().Default.Debug.RequestInfoLogPath == \"\" { panic(\"unable to create request info log file. File path not set\") } WriteLog( config.LoadedConfig().Default.Debug.SkipLoggingLevel, config.LoadedConfig().Default.Debug.RequestInfoLogPath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, prefix, message, -1, ) } RequestLogginIfEnable Logs request information if request logging is enabled. func RequestLogginIfEnable(prefix string, message string) { if config.LoadedConfig().Default.Debug.RequestInfoLog { LogRequestInfo(prefix, message) } }","title":"Logging"},{"location":"debug/logging/#debug","text":"This package contains tools for debugging.","title":"Debug"},{"location":"debug/logging/#writelog","text":"WriteLog writes the message to a log file. skipLevel - skips levels of runtime.Caller. This is used to output the path on which the log is written. filePath - path to the log file. flag - flags for opening a file from the os package. prefix - prefix that will be shown in the log. It is desirable to use constants \u201cP_...\u201d from this package. message - the message that will be recorded. func WriteLog(skipLevel int, filePath string, flag int, prefix string, message string, logFlags int) { var _logFlags int if logFlags == -1 { _logFlags = log.LstdFlags } f, err := os.OpenFile(filePath, flag, 0666) if err != nil { fmt.Println(\"LogError: \", err.Error()) return } defer func(f *os.File) { err := f.Close() if err != nil { fmt.Println(\"LogError: \", err.Error()) return } }(f) ilog := log.New(f, fmt.Sprintf(\"[%s] \", prefix), _logFlags) ilog.SetFlags(_logFlags) if skipLevel < 0 { skipLevel = 3 } _, file, line, ok := runtime.Caller(skipLevel) if !ok { ilog.Println(\"Could not retrieve caller information\") return } loggingFilePath := file if config.LoadedConfig().Default.Debug.DebugRelativeFilepath { wd, err := os.Getwd() if err != nil { ilog.Println(\"Could not retrieve working directory:\", err) return } relPath, err := filepath.Rel(wd, file) if err != nil { ilog.Println(\"Could not calculate relative path:\", err) return } loggingFilePath = relPath } ilog.Printf(\"%s:%d %s\\n\", loggingFilePath, line, message) }","title":"WriteLog"},{"location":"debug/logging/#logerror","text":"Logs errors to the error log. func LogError(message string) { if config.LoadedConfig().Default.Debug.ErrorLoggingPath == \"\" { panic(\"unable to create log file. File path not set\") } WriteLog( config.LoadedConfig().Default.Debug.SkipLoggingLevel+1, config.LoadedConfig().Default.Debug.ErrorLoggingPath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, \"\", message, -1, ) }","title":"LogError"},{"location":"debug/logging/#errorloggingifenableandwrite","text":"Writes a message to the log if error logging is enabled. This function also writes a message to the browser page. It is convenient for displaying the error on the page. func ErrorLoggingIfEnableAndWrite(w http.ResponseWriter, errorText string, writeText string) { _, err := w.Write([]byte(writeText)) if err != nil { if config.LoadedConfig().Default.Debug.ErrorLogging { LogError(err.Error()) } } if config.LoadedConfig().Default.Debug.ErrorLogging { LogError(string(errorText)) } }","title":"ErrorLoggingIfEnableAndWrite"},{"location":"debug/logging/#errorlogginifenable","text":"Writes a message to the log if error logging is enabled. func ErrorLogginIfEnable(message string) { if config.LoadedConfig().Default.Debug.ErrorLogging { LogError(message) } }","title":"ErrorLogginIfEnable"},{"location":"debug/logging/#clearrequestinfologging","text":"Clears the request log. func ClearRequestInfoLogging() error { if config.LoadedConfig().Default.Debug.RequestInfoLogPath != \"\" && fpath.PathExist(config.LoadedConfig().Default.Debug.RequestInfoLogPath) { f, err := os.OpenFile(config.LoadedConfig().Default.Debug.RequestInfoLogPath, os.O_WRONLY, 0644) if err != nil { return err } defer f.Close() if err := f.Truncate(0); err != nil { return err } } return nil }","title":"ClearRequestInfoLogging"},{"location":"debug/logging/#logrequestinfo","text":"Logs information about the request. func LogRequestInfo(prefix string, message string) { if config.LoadedConfig().Default.Debug.RequestInfoLogPath == \"\" { panic(\"unable to create request info log file. File path not set\") } WriteLog( config.LoadedConfig().Default.Debug.SkipLoggingLevel, config.LoadedConfig().Default.Debug.RequestInfoLogPath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, prefix, message, -1, ) }","title":"LogRequestInfo"},{"location":"debug/logging/#requestlogginifenable","text":"Logs request information if request logging is enabled. func RequestLogginIfEnable(prefix string, message string) { if config.LoadedConfig().Default.Debug.RequestInfoLog { LogRequestInfo(prefix, message) } }","title":"RequestLogginIfEnable"},{"location":"mapper/dbmapper/","text":"dbmapper FillStructSliceFromDb Fills a slice with data from the database. It uses FillStructFromDb function for filling. func FillStructSliceFromDb[T any](slice *[]T, dbRes *[]map[string]interface{}) error { if len(*slice) != len(*dbRes) { return errors.New(\"the length of the fill slice is not the same as the length of the data slice\") } for i := 0; i < len(*dbRes); i++ { if err := FillStructFromDb(&(*slice)[i], &(*dbRes)[i]); err != nil { return err } } return nil } FillStructFromDb Fills the structure with data from the database. It needs the db:\"<field_name>\" tag to work properly. The name of the tag must match the name of the column. If there is no tag, the field is skipped. Caches the structure using the implemented RawObject interface. This means that all subsequent accesses to this structure will be faster. func FillStructFromDb[T any](fillStruct *T, dbRes *map[string]interface{}) error { v := typeopr.GetReflectValue(fillStruct) raw := LoadSomeRawObjectFromCache(v, &dbRawCache, namelib.TAGS.DB_MAPPER_NAME) for name, f := range *raw.Fields() { field := v.FieldByName(f.Name) data, ok := (*dbRes)[name] if ok { // Processing DB_MAPPER_EMPTY tag. if data == nil { emptyVal := f.Tag.Get(namelib.TAGS.DB_MAPPER_EMPTY) if emptyVal != \"\" { if emptyVal == \"-error\" { return typeopr.ErrValueIsEmpty{Value: name} } newByteData, err := DC.dbValueConversionToByte(emptyVal) if err != nil { return err } newData := reflect.ValueOf(newByteData).Interface() if err := DC.convertDBType(&field, &f.Tag, &newData); err != nil { return err } } } else { if err := DC.convertDBType(&field, &f.Tag, &data); err != nil { return err } } } } return nil } ParamsValueFromDbStruct Creates a map from a structure that describes the table. To work correctly, you need a completed structure, and the required fields must have the db:\"<column name>\" tag. func ParamsValueFromDbStruct(filledStructurePtr typeopr.IPtr, nilIfEmpty []string) (map[string]any, error) { structure := filledStructurePtr.Ptr() if !typeopr.PtrIsStruct(structure) { return nil, typeopr.ErrParameterNotStruct{Param: \"structure\"} } outputParamsMap := make(map[string]any) typeof := reflect.TypeOf(structure).Elem() valueof := reflect.ValueOf(structure).Elem() for i := 0; i < typeof.NumField(); i++ { fieldValue := valueof.Field(i) dbColName := typeof.Field(i).Tag.Get(namelib.TAGS.DB_MAPPER_NAME) if dbColName == \"\" { continue } if fslice.SliceContains(nilIfEmpty, dbColName) && fieldValue.IsZero() { outputParamsMap[dbColName] = nil } else { outputParamsMap[dbColName] = fieldValue.Interface() } } return outputParamsMap, nil }","title":"Dbmapper"},{"location":"mapper/dbmapper/#dbmapper","text":"","title":"dbmapper"},{"location":"mapper/dbmapper/#fillstructslicefromdb","text":"Fills a slice with data from the database. It uses FillStructFromDb function for filling. func FillStructSliceFromDb[T any](slice *[]T, dbRes *[]map[string]interface{}) error { if len(*slice) != len(*dbRes) { return errors.New(\"the length of the fill slice is not the same as the length of the data slice\") } for i := 0; i < len(*dbRes); i++ { if err := FillStructFromDb(&(*slice)[i], &(*dbRes)[i]); err != nil { return err } } return nil }","title":"FillStructSliceFromDb"},{"location":"mapper/dbmapper/#fillstructfromdb","text":"Fills the structure with data from the database. It needs the db:\"<field_name>\" tag to work properly. The name of the tag must match the name of the column. If there is no tag, the field is skipped. Caches the structure using the implemented RawObject interface. This means that all subsequent accesses to this structure will be faster. func FillStructFromDb[T any](fillStruct *T, dbRes *map[string]interface{}) error { v := typeopr.GetReflectValue(fillStruct) raw := LoadSomeRawObjectFromCache(v, &dbRawCache, namelib.TAGS.DB_MAPPER_NAME) for name, f := range *raw.Fields() { field := v.FieldByName(f.Name) data, ok := (*dbRes)[name] if ok { // Processing DB_MAPPER_EMPTY tag. if data == nil { emptyVal := f.Tag.Get(namelib.TAGS.DB_MAPPER_EMPTY) if emptyVal != \"\" { if emptyVal == \"-error\" { return typeopr.ErrValueIsEmpty{Value: name} } newByteData, err := DC.dbValueConversionToByte(emptyVal) if err != nil { return err } newData := reflect.ValueOf(newByteData).Interface() if err := DC.convertDBType(&field, &f.Tag, &newData); err != nil { return err } } } else { if err := DC.convertDBType(&field, &f.Tag, &data); err != nil { return err } } } } return nil }","title":"FillStructFromDb"},{"location":"mapper/dbmapper/#paramsvaluefromdbstruct","text":"Creates a map from a structure that describes the table. To work correctly, you need a completed structure, and the required fields must have the db:\"<column name>\" tag. func ParamsValueFromDbStruct(filledStructurePtr typeopr.IPtr, nilIfEmpty []string) (map[string]any, error) { structure := filledStructurePtr.Ptr() if !typeopr.PtrIsStruct(structure) { return nil, typeopr.ErrParameterNotStruct{Param: \"structure\"} } outputParamsMap := make(map[string]any) typeof := reflect.TypeOf(structure).Elem() valueof := reflect.ValueOf(structure).Elem() for i := 0; i < typeof.NumField(); i++ { fieldValue := valueof.Field(i) dbColName := typeof.Field(i).Tag.Get(namelib.TAGS.DB_MAPPER_NAME) if dbColName == \"\" { continue } if fslice.SliceContains(nilIfEmpty, dbColName) && fieldValue.IsZero() { outputParamsMap[dbColName] = nil } else { outputParamsMap[dbColName] = fieldValue.Interface() } } return outputParamsMap, nil }","title":"ParamsValueFromDbStruct"},{"location":"mapper/dtomapper/","text":"dtomapper DeepCheckDTOSafeMessage Checks whether transmitted messages and internal messages are safe. That is, there will be a check of internal structures, in depth to the limit. It is mandatory to have \u201cdto\u201d tags for each field. IMPORTANT : messagePtr accepts a pointer to a structure (preferably) or a pointer to a structure interface. In both cases, the object must implement the irest.IMessage interface. func DeepCheckDTOSafeMessage(dto *rest.DTO, messagePtr typeopr.IPtr) error { if err := rest.IsSafeMessage(messagePtr, dto.GetAllowedMessages()); err != nil { return err } message := reflect.ValueOf(messagePtr.Ptr()).Elem() var RV reflect.Value if message.Type().Kind() == reflect.Interface { RV = message.Elem() } else { RV = message } rawObject := LoadSomeRawObjectFromCache(RV, &messageRawCache, namelib.TAGS.DTO) for _, f := range *rawObject.Fields() { if f.Type.Kind() == reflect.Struct && f.Type != implementDTOMessageType && f.Type != typeIdType { v := RV.FieldByName(f.Name) i := v.Interface().(irest.Message) if err := DeepCheckDTOSafeMessage(dto, typeopr.Ptr{}.New(&i)); err != nil { return err } } } return nil } JsonToDTOMessage Converts JSON data into the selected message. It is important that the message is safe. func JsonToDTOMessage[T any](jsonData map[string]interface{}, dto *rest.DTO, output *T) error { if err := DeepCheckDTOSafeMessage(dto, typeopr.Ptr{}.New(output)); err != nil { return err } if err := FillDTOMessageFromMap(jsonData, output); err != nil { return err } return nil } SendSafeJsonDTOMessage Sends only safe messages in JSON format. func SendSafeJsonDTOMessage(w http.ResponseWriter, code int, dto *rest.DTO, message typeopr.IPtr) error { if err := DeepCheckDTOSafeMessage(dto, message); err != nil { return err } if err := router.SendJson(message.Ptr(), w, code); err != nil { return err } return nil } FillDTOMessageFromMap Fills in a message from the card. To work you need to use the \"dto\" tag. If the DTO message is initially created correctly, there should be no problem with this function. func FillDTOMessageFromMap[T any](jsonMap map[string]interface{}, out *T) error { if jsonMap == nil || out == nil { return errors.New(\"nil input to FillMessageFromMap\") } RV := typeopr.GetReflectValue(out) if !typeopr.IsImplementInterface(typeopr.Ptr{}.New(out), (*irest.Message)(nil)) { return errors.New(\"output param must implement the irest.IMessage interface\") } rawObject := LoadSomeRawObjectFromCache(RV, &messageRawCache, namelib.TAGS.DTO) for name, f := range *rawObject.Fields() { inputValue, ok := (jsonMap)[name] if !ok { continue } fieldValue := RV.FieldByName(f.Name) switch f.Type.Kind() { case reflect.Struct: v, ok := inputValue.(map[string]interface{}) if !ok { return fmt.Errorf(\"expected object for field '%s'\", name) } if err := FillDTOMessageFromMap(v, &fieldValue); err != nil { return err } default: if err := fillField(&fieldValue, inputValue); err != nil { return err } } } return nil }","title":"Dtomapper"},{"location":"mapper/dtomapper/#dtomapper","text":"","title":"dtomapper"},{"location":"mapper/dtomapper/#deepcheckdtosafemessage","text":"Checks whether transmitted messages and internal messages are safe. That is, there will be a check of internal structures, in depth to the limit. It is mandatory to have \u201cdto\u201d tags for each field. IMPORTANT : messagePtr accepts a pointer to a structure (preferably) or a pointer to a structure interface. In both cases, the object must implement the irest.IMessage interface. func DeepCheckDTOSafeMessage(dto *rest.DTO, messagePtr typeopr.IPtr) error { if err := rest.IsSafeMessage(messagePtr, dto.GetAllowedMessages()); err != nil { return err } message := reflect.ValueOf(messagePtr.Ptr()).Elem() var RV reflect.Value if message.Type().Kind() == reflect.Interface { RV = message.Elem() } else { RV = message } rawObject := LoadSomeRawObjectFromCache(RV, &messageRawCache, namelib.TAGS.DTO) for _, f := range *rawObject.Fields() { if f.Type.Kind() == reflect.Struct && f.Type != implementDTOMessageType && f.Type != typeIdType { v := RV.FieldByName(f.Name) i := v.Interface().(irest.Message) if err := DeepCheckDTOSafeMessage(dto, typeopr.Ptr{}.New(&i)); err != nil { return err } } } return nil }","title":"DeepCheckDTOSafeMessage"},{"location":"mapper/dtomapper/#jsontodtomessage","text":"Converts JSON data into the selected message. It is important that the message is safe. func JsonToDTOMessage[T any](jsonData map[string]interface{}, dto *rest.DTO, output *T) error { if err := DeepCheckDTOSafeMessage(dto, typeopr.Ptr{}.New(output)); err != nil { return err } if err := FillDTOMessageFromMap(jsonData, output); err != nil { return err } return nil }","title":"JsonToDTOMessage"},{"location":"mapper/dtomapper/#sendsafejsondtomessage","text":"Sends only safe messages in JSON format. func SendSafeJsonDTOMessage(w http.ResponseWriter, code int, dto *rest.DTO, message typeopr.IPtr) error { if err := DeepCheckDTOSafeMessage(dto, message); err != nil { return err } if err := router.SendJson(message.Ptr(), w, code); err != nil { return err } return nil }","title":"SendSafeJsonDTOMessage"},{"location":"mapper/dtomapper/#filldtomessagefrommap","text":"Fills in a message from the card. To work you need to use the \"dto\" tag. If the DTO message is initially created correctly, there should be no problem with this function. func FillDTOMessageFromMap[T any](jsonMap map[string]interface{}, out *T) error { if jsonMap == nil || out == nil { return errors.New(\"nil input to FillMessageFromMap\") } RV := typeopr.GetReflectValue(out) if !typeopr.IsImplementInterface(typeopr.Ptr{}.New(out), (*irest.Message)(nil)) { return errors.New(\"output param must implement the irest.IMessage interface\") } rawObject := LoadSomeRawObjectFromCache(RV, &messageRawCache, namelib.TAGS.DTO) for name, f := range *rawObject.Fields() { inputValue, ok := (jsonMap)[name] if !ok { continue } fieldValue := RV.FieldByName(f.Name) switch f.Type.Kind() { case reflect.Struct: v, ok := inputValue.(map[string]interface{}) if !ok { return fmt.Errorf(\"expected object for field '%s'\", name) } if err := FillDTOMessageFromMap(v, &fieldValue); err != nil { return err } default: if err := fillField(&fieldValue, inputValue); err != nil { return err } } } return nil }","title":"FillDTOMessageFromMap"},{"location":"mapper/formmapper/","text":"formmapper FillStructFromForm Fills the structure with data from the form. All standard types and form.FormFile for files are supported. Slices with all these types are also supported. Does not work with nested structures. Before passing the form to the function, it must be pre-processed using the Parse method. All fields that have the tag form:\"<input_name>\" will be processed. Where <input_name> is the name of the key (or HTML input) to the data in the form. Form field data can exist in three types: Just data from the form. For example, strings or numbers. Empty data. An empty string \"\" is passed. There is no data. Data is expected, but it is not present in any way. There are special tags to handle the first and second cases. Namely: empty \u2014 executed in the second case, when the string is empty. Tag with empty value is ignored. It has several arguments: empty:\"<some_text>\" - the value that will be passed to the structure field. You can pass, for example, a number, it will be formatted if the field type is int. empty:\"-err\" - will print the corresponding error if the field is empty. nil - is executed when it is impossible to find data in the form by the current key, which means that there is no data. You can pass the arguments: nil:\"-skip\" - skips the given field. If the tag \"nil\" is not set, there will be an error because of an undiscovered key. func FillStructFromForm[T any](frm *form.Form, out *T) error { of := FrmValueToOrderedForm(frm) v := typeopr.GetReflectValue(out) raw := LoadSomeRawObjectFromCache(v, &frmRawCache, namelib.TAGS.FORM_MAPPER_NAME) for name, f := range *raw.Fields() { fieldValue := v.FieldByName(f.Name) orderedFormValues, ok := of.GetByName(name) if !ok { switch f.Tag.Get(namelib.TAGS.FORM_MAPPER_NIL) { case NIL_SKIP: continue default: return form.ErrFormConvertFieldNotFound{Field: name} } } if err := FC.handleItem(&orderedFormValues, &fieldValue, f.Name, f.Tag.Get(namelib.TAGS.FORM_MAPPER_EMPTY)); err != nil { return err } } if err := CheckExtension(out); err != nil { return err } return nil } CheckExtension Check if the file resolution matches the expected one. Can only be used with a structure already filled out in the form. To work, you need to add an ext tag with the necessary extensions (if there are many, separated by commas). For example, ext:\".jpg .jpeg .png\" . func CheckExtension[T any](filledStruct *T) error { v := typeopr.GetReflectValue(filledStruct) raw := LoadSomeRawObjectFromCache(v, &frmRawCache, namelib.TAGS.FORM_MAPPER_NAME) for _, f := range *raw.Fields() { fieldValue := v.FieldByName(f.Name) extensionsString := f.Tag.Get(namelib.TAGS.FORM_MAPPER_EXTENSION) if extensionsString == \"\" { continue } extensionSlice := strings.Split(extensionsString, \" \") switch f.Type.Kind() { case reflect.Slice: if f.Type.Elem() != formFileType { panic(\"the ext tag can only be added to fields whose type is form.FormFile\") } files := fieldValue.Interface().([]form.FormFile) for i := 0; i < len(files); i++ { if !slices.Contains(extensionSlice, filepath.Ext(files[i].Header.Filename)) { return ErrExtensionNotMatch{Field: f.Name} } } case reflect.Struct: if f.Type != formFileType { panic(\"the ext tag can only be added to fields whose type is form.FormFile\") } fmt.Println(fieldValue) file := fieldValue.Interface().(form.FormFile) if !slices.Contains(extensionSlice, filepath.Ext(file.Header.Filename)) { return ErrExtensionNotMatch{Field: f.Name} } } } return nil }","title":"Formmapper"},{"location":"mapper/formmapper/#formmapper","text":"","title":"formmapper"},{"location":"mapper/formmapper/#fillstructfromform","text":"Fills the structure with data from the form. All standard types and form.FormFile for files are supported. Slices with all these types are also supported. Does not work with nested structures. Before passing the form to the function, it must be pre-processed using the Parse method. All fields that have the tag form:\"<input_name>\" will be processed. Where <input_name> is the name of the key (or HTML input) to the data in the form. Form field data can exist in three types: Just data from the form. For example, strings or numbers. Empty data. An empty string \"\" is passed. There is no data. Data is expected, but it is not present in any way. There are special tags to handle the first and second cases. Namely: empty \u2014 executed in the second case, when the string is empty. Tag with empty value is ignored. It has several arguments: empty:\"<some_text>\" - the value that will be passed to the structure field. You can pass, for example, a number, it will be formatted if the field type is int. empty:\"-err\" - will print the corresponding error if the field is empty. nil - is executed when it is impossible to find data in the form by the current key, which means that there is no data. You can pass the arguments: nil:\"-skip\" - skips the given field. If the tag \"nil\" is not set, there will be an error because of an undiscovered key. func FillStructFromForm[T any](frm *form.Form, out *T) error { of := FrmValueToOrderedForm(frm) v := typeopr.GetReflectValue(out) raw := LoadSomeRawObjectFromCache(v, &frmRawCache, namelib.TAGS.FORM_MAPPER_NAME) for name, f := range *raw.Fields() { fieldValue := v.FieldByName(f.Name) orderedFormValues, ok := of.GetByName(name) if !ok { switch f.Tag.Get(namelib.TAGS.FORM_MAPPER_NIL) { case NIL_SKIP: continue default: return form.ErrFormConvertFieldNotFound{Field: name} } } if err := FC.handleItem(&orderedFormValues, &fieldValue, f.Name, f.Tag.Get(namelib.TAGS.FORM_MAPPER_EMPTY)); err != nil { return err } } if err := CheckExtension(out); err != nil { return err } return nil }","title":"FillStructFromForm"},{"location":"mapper/formmapper/#checkextension","text":"Check if the file resolution matches the expected one. Can only be used with a structure already filled out in the form. To work, you need to add an ext tag with the necessary extensions (if there are many, separated by commas). For example, ext:\".jpg .jpeg .png\" . func CheckExtension[T any](filledStruct *T) error { v := typeopr.GetReflectValue(filledStruct) raw := LoadSomeRawObjectFromCache(v, &frmRawCache, namelib.TAGS.FORM_MAPPER_NAME) for _, f := range *raw.Fields() { fieldValue := v.FieldByName(f.Name) extensionsString := f.Tag.Get(namelib.TAGS.FORM_MAPPER_EXTENSION) if extensionsString == \"\" { continue } extensionSlice := strings.Split(extensionsString, \" \") switch f.Type.Kind() { case reflect.Slice: if f.Type.Elem() != formFileType { panic(\"the ext tag can only be added to fields whose type is form.FormFile\") } files := fieldValue.Interface().([]form.FormFile) for i := 0; i < len(files); i++ { if !slices.Contains(extensionSlice, filepath.Ext(files[i].Header.Filename)) { return ErrExtensionNotMatch{Field: f.Name} } } case reflect.Struct: if f.Type != formFileType { panic(\"the ext tag can only be added to fields whose type is form.FormFile\") } fmt.Println(fieldValue) file := fieldValue.Interface().(form.FormFile) if !slices.Contains(extensionSlice, filepath.Ext(file.Header.Filename)) { return ErrExtensionNotMatch{Field: f.Name} } } } return nil }","title":"CheckExtension"},{"location":"mapper/mapper/","text":"mapper This package is used for mapping data to a data structure. The reflect package is actively used for the mapper's operation. Therefore, the key feature of the package is the use of caching. The LoadSomeRawObjectFromCache function is used to create and subsequently load the cache. Example of use: var rawCache sync.Map ... v := typeopr.GetReflectValue(out) raw := LoadSomeRawObjectFromCache(v, &rawCache, namelib.TAGS.FORM_MAPPER_NAME) ... There are several types of mappers: dbmapper formmapper dtomapper RawObject RawObject is used to store data of type undefined structure. This structure is intended to optimize the work of the reflect package with the structure. The type of the structure itself and its field types are stored here. This object reduces the load on the structure parser, now it is not necessary to loop through all fields. Also this object is convenient because it can store only selected fields of the structure, which makes it more convenient to use. Fields are passed by the map so that it is possible to give them a custom tag name. If the tag is not needed, the key can be the field name. IMPORTANT : to get better performance you should store an instance of this object in a separate immutable variable. type RawObject interface { // Type returns the type of the stored object. Type() reflect.Type // Fields returns the selected fields of the stored object. // It can store not all fields, but only those added by the implementation. Fields() *map[string]reflect.StructField } SomeRawObject Object stores structure data to be filled with data from the data base. It implements the RawStruct interface. type SomeRawObject struct { typ reflect.Type fields *map[string]reflect.StructField } NewSomeRawObjectWithTag Creates and fills a new instance of SomeRawObject from a given object. Accepts an object as a direct instance or reflect.Value object. Only fields that have the <tag_name>:<field_name> tag will be stored. This tag must contain the names of the column in the table, for which the structure field is intended. The names must exactly match. If there is no tag, the field will be simply skipped. func NewSomeRawObjectWithTag[T any](target *T, tagName string) RawObject { t := typeopr.GetReflectValue(target).Type() fields := make(map[string]reflect.StructField) for i := 0; i < t.NumField(); i++ { field := t.Field(i) fieldDbTagName := field.Tag.Get(tagName) // Skip field if tag empty. if fieldDbTagName == \"\" { continue } fields[fieldDbTagName] = field } return &SomeRawObject{ typ: t, fields: &fields, } } LoadSomeRawObjectFromCache Loads an object from the selected cache. If the object is not in the cache, creates a RawObject for it and sets it. func LoadSomeRawObjectFromCache(objectValue reflect.Value, rawCache *sync.Map, tagName string) RawObject { var raw RawObject objectType := objectValue.Type() if storedRaw, ok := rawCache.Load(objectType); ok { raw = storedRaw.(RawObject) } else { raw = NewSomeRawObjectWithTag(&objectValue, tagName) rawCache.Store(objectType, raw) } return raw }","title":"Mapper"},{"location":"mapper/mapper/#mapper","text":"This package is used for mapping data to a data structure. The reflect package is actively used for the mapper's operation. Therefore, the key feature of the package is the use of caching. The LoadSomeRawObjectFromCache function is used to create and subsequently load the cache. Example of use: var rawCache sync.Map ... v := typeopr.GetReflectValue(out) raw := LoadSomeRawObjectFromCache(v, &rawCache, namelib.TAGS.FORM_MAPPER_NAME) ... There are several types of mappers: dbmapper formmapper dtomapper","title":"mapper"},{"location":"mapper/mapper/#rawobject","text":"RawObject is used to store data of type undefined structure. This structure is intended to optimize the work of the reflect package with the structure. The type of the structure itself and its field types are stored here. This object reduces the load on the structure parser, now it is not necessary to loop through all fields. Also this object is convenient because it can store only selected fields of the structure, which makes it more convenient to use. Fields are passed by the map so that it is possible to give them a custom tag name. If the tag is not needed, the key can be the field name. IMPORTANT : to get better performance you should store an instance of this object in a separate immutable variable. type RawObject interface { // Type returns the type of the stored object. Type() reflect.Type // Fields returns the selected fields of the stored object. // It can store not all fields, but only those added by the implementation. Fields() *map[string]reflect.StructField }","title":"RawObject"},{"location":"mapper/mapper/#somerawobject","text":"Object stores structure data to be filled with data from the data base. It implements the RawStruct interface. type SomeRawObject struct { typ reflect.Type fields *map[string]reflect.StructField }","title":"SomeRawObject"},{"location":"mapper/mapper/#newsomerawobjectwithtag","text":"Creates and fills a new instance of SomeRawObject from a given object. Accepts an object as a direct instance or reflect.Value object. Only fields that have the <tag_name>:<field_name> tag will be stored. This tag must contain the names of the column in the table, for which the structure field is intended. The names must exactly match. If there is no tag, the field will be simply skipped. func NewSomeRawObjectWithTag[T any](target *T, tagName string) RawObject { t := typeopr.GetReflectValue(target).Type() fields := make(map[string]reflect.StructField) for i := 0; i < t.NumField(); i++ { field := t.Field(i) fieldDbTagName := field.Tag.Get(tagName) // Skip field if tag empty. if fieldDbTagName == \"\" { continue } fields[fieldDbTagName] = field } return &SomeRawObject{ typ: t, fields: &fields, } }","title":"NewSomeRawObjectWithTag"},{"location":"mapper/mapper/#loadsomerawobjectfromcache","text":"Loads an object from the selected cache. If the object is not in the cache, creates a RawObject for it and sets it. func LoadSomeRawObjectFromCache(objectValue reflect.Value, rawCache *sync.Map, tagName string) RawObject { var raw RawObject objectType := objectValue.Type() if storedRaw, ok := rawCache.Load(objectType); ok { raw = storedRaw.(RawObject) } else { raw = NewSomeRawObjectWithTag(&objectValue, tagName) rawCache.Store(objectType, raw) } return raw }","title":"LoadSomeRawObjectFromCache"},{"location":"mapper/orderedform/","text":"orderedform OrderedForm This structure is used to store the ordered data of the form. This is necessary to ensure that the data is in the same order each time the form is used. type OrderedForm struct { itemCount int names map[string][]int values []OrderedFormValue } OrderedForm.Add Add a new form field. func (f *OrderedForm) Add(name string, value interface{}) { f.values = append(f.values, OrderedFormValue{ Name: name, Value: value, }) f.itemCount++ f.names[name] = append(f.names[name], f.itemCount) } OrderedForm.GetByName Getting a field by name. func (f *OrderedForm) GetByName(name string) ([]OrderedFormValue, bool) { getIndex, ok := f.names[name] if !ok { return nil, ok } res := []OrderedFormValue{} for i := 0; i < len(getIndex); i++ { res = append(res, f.values[getIndex[i]-1]) } return res, true } OrderedForm.GetAll Getting all fields. func (f *OrderedForm) GetAll() []OrderedFormValue { return f.values } OrderedFormValue Single value of a form field. type OrderedFormValue struct { Name string Value interface{} } FrmValueToOrderedForm Converts the form to a OrderedForm . func FrmValueToOrderedForm(frm IFormGetEnctypeData) *OrderedForm { orderedForm := NewOrderedForm() multipartForm := frm.GetMultipartForm() if multipartForm != nil { for name, value := range multipartForm.Value { orderedForm.Add(name, value) } for name, value := range multipartForm.File { var files []form.FormFile for i := 0; i < len(value); i++ { files = append(files, form.FormFile{Header: value[i]}) } orderedForm.Add(name, files) } } applicationForm := frm.GetApplicationForm() if applicationForm != nil { for name, value := range applicationForm { orderedForm.Add(name, value) } } return orderedForm }","title":"Orderedform"},{"location":"mapper/orderedform/#orderedform","text":"","title":"orderedform"},{"location":"mapper/orderedform/#orderedform_1","text":"This structure is used to store the ordered data of the form. This is necessary to ensure that the data is in the same order each time the form is used. type OrderedForm struct { itemCount int names map[string][]int values []OrderedFormValue }","title":"OrderedForm"},{"location":"mapper/orderedform/#orderedformadd","text":"Add a new form field. func (f *OrderedForm) Add(name string, value interface{}) { f.values = append(f.values, OrderedFormValue{ Name: name, Value: value, }) f.itemCount++ f.names[name] = append(f.names[name], f.itemCount) }","title":"OrderedForm.Add"},{"location":"mapper/orderedform/#orderedformgetbyname","text":"Getting a field by name. func (f *OrderedForm) GetByName(name string) ([]OrderedFormValue, bool) { getIndex, ok := f.names[name] if !ok { return nil, ok } res := []OrderedFormValue{} for i := 0; i < len(getIndex); i++ { res = append(res, f.values[getIndex[i]-1]) } return res, true }","title":"OrderedForm.GetByName"},{"location":"mapper/orderedform/#orderedformgetall","text":"Getting all fields. func (f *OrderedForm) GetAll() []OrderedFormValue { return f.values }","title":"OrderedForm.GetAll"},{"location":"mapper/orderedform/#orderedformvalue","text":"Single value of a form field. type OrderedFormValue struct { Name string Value interface{} }","title":"OrderedFormValue"},{"location":"mapper/orderedform/#frmvaluetoorderedform","text":"Converts the form to a OrderedForm . func FrmValueToOrderedForm(frm IFormGetEnctypeData) *OrderedForm { orderedForm := NewOrderedForm() multipartForm := frm.GetMultipartForm() if multipartForm != nil { for name, value := range multipartForm.Value { orderedForm.Add(name, value) } for name, value := range multipartForm.File { var files []form.FormFile for i := 0; i < len(value); i++ { files = append(files, form.FormFile{Header: value[i]}) } orderedForm.Add(name, files) } } applicationForm := frm.GetApplicationForm() if applicationForm != nil { for name, value := range applicationForm { orderedForm.Add(name, value) } } return orderedForm }","title":"FrmValueToOrderedForm"},{"location":"router/router/","text":"package router Globally, the router package is responsible for two functions: Preparing and running handlers via Adapter . Registering and running http methods. This is the responsibility of Router . In general, the algorithm of route processing is as follows: Register the handler on the route using the Register method. Passing the handler to Adapter and receiving the same handler, but in a special wrapper. Adding the http method, path pattern and adapted handler to the route processing list. When url and path pattern match, the adapted handler will start. Adapter The Adapter object is needed to adapt the handler to work with the rest of the framework modules. The object is also needed to control the handler in a more flexible way. In general, Adapter should wrap the passed handler to work with other modules, and then this wrapper will be launched in Router . The adapter's responsibilities include the following items: Clearing logs before running the handler Creating a new instance of the Manager object. Setting some Manager.OneTimeData variables Running all types of middleware Running the original handler Outputting request logs to the console Adapter.Adapt This is the main method that wraps the source handler and thus runs all the necessary modules. In general, its implementation is quite simple, but there are a few nuances: Instead of http.ResponseWriter , BufferedResponseWriter is used. If the connection is a websocket, PostMiddlewares are not run BufferedResponseWriter BufferedResponseWriter is a wrapper over http.ResponseWriter . The wrapper is needed to give more flexible control over how data is written to the page. This object fully implements the http.ResponseWriter interface, but the difference is that the Write method does not send the request immediately, but buffers it. To actually write the data you need to use the Flush method. BufferedResponseWriter.Flush A simple method that writes data to the original http.ResponseWriter . Accordingly, the data is sent immediately. func (rw *BufferedResponseWriter) Flush() (int, error) { for k, vv := range rw.header { for _, v := range vv { rw.original.Header().Add(k, v) } } rw.original.WriteHeader(rw.statusCode) return rw.original.Write(rw.buffer.Bytes()) } Router The Router object is used to route http requests. The algorithm of its work looks like this: Obtaining the url address Searching for url address match in stored url templates Running a handler that is bound to the url template Router.HandlerSet Gegisters multiple handlers at once. Does everything the same as Router.Register , but only with multiple handlers. The method is just for convenience. Example Usage: newRouter.HandlerSet( map[string][]map[string]router.Handler{ router.MethodGET: { {\"/home\": homeHandler}, {\"/about\": aboutHandler}, }, router.MethodPOST: { {\"/register\": registerHandler}, }, } ) Router.Register It simply registers a handler on the selected path. Uses Adapter to wrap the handler. newRouter.Register(router.MethodGET, \"/page\", func(w http.ResponseWriter, r *http.Request, manager interfaces.Manager) error { manager.Render().SetTemplatePath(\"index.html\") if err := manager.Render().RenderTemplate(w, r); err != nil { return err } return nil }) Router.ServeHTTP Implements the http.Handler interface. It is used to call handlers. RedirectError The function redirects to the selected url. Also, the url parameters are redirected with an error from the function arguments. func RedirectError(w http.ResponseWriter, r *http.Request, path string, _err string) { uval := url.Values{} uval.Add(namelib.ROUTER.REDIRECT_ERROR, _err) newUrl := fmt.Sprintf(\"%s?%s\", path, uval.Encode()) http.Redirect(w, r, newUrl, http.StatusFound) debug.ErrorLogginIfEnable(_err) debug.RequestLogginIfEnable(debug.P_ERROR, _err) } CatchRedirectError Catches an error from url parameters that is passed through the RedirectError function. Sets the error to the manager context. If there is a Render instance in Manager , sets the error to its context. Both contexts are handled by the namelib.ROUTER.REDIRECT_ERROR key. func CatchRedirectError(r *http.Request, manager interfaces.Manager) { q := r.URL.Query() redirectError := q.Get(namelib.ROUTER.REDIRECT_ERROR) if redirectError != \"\" { if manager.Render() != nil { manager.Render().SetContext(map[string]interface{}{namelib.ROUTER.REDIRECT_ERROR: redirectError}) } manager.OneTimeData().SetUserContext(namelib.ROUTER.REDIRECT_ERROR, redirectError) } } ServerError Sends an error with code 500 and the text \"500 Internal server error\" to the page. The text is sent using the special function TODO: link debug.ErrorLoggingIfEnableAndWrite . func ServerError(w http.ResponseWriter, error string, manager interfaces.Manager) { manager.OneTimeData().SetUserContext(namelib.ROUTER.SERVER_ERROR, error) w.WriteHeader(http.StatusInternalServerError) if config.LoadedConfig().Default.Debug.Debug { debug.ErrorLoggingIfEnableAndWrite(w, error, error) } else { debug.ErrorLoggingIfEnableAndWrite(w, error, \"500 Internal server error\") } debug.RequestLogginIfEnable(debug.P_ERROR, error) } ServerForbidden Sends an error with code 403 and text \"500 Internal server error\" to the page. The text is sent using the special function TODO: link debug.ErrorLoggingIfEnableAndWrite . func ServerForbidden(w http.ResponseWriter, manager interfaces.Manager) { manager.OneTimeData().SetUserContext(namelib.ROUTER.SERVER_FORBIDDEN_ERROR, \"403 forbidden\") w.WriteHeader(http.StatusForbidden) debug.ErrorLoggingIfEnableAndWrite(w, \"403 forbidden\", \"403 forbidden\") debug.RequestLogginIfEnable(debug.P_ERROR, \"403 forbidden\") } SendJson Sends Json as a response to an http request. func SendJson(data interface{}, w http.ResponseWriter, code int) error { marshal, err := json.Marshal(data) if err != nil { return err } w.Header().Set(\"Content-Type\", \"application/json\") w.WriteHeader(code) _, err = w.Write(marshal) if err != nil { return err } return nil }","title":"Router"},{"location":"router/router/#package-router","text":"Globally, the router package is responsible for two functions: Preparing and running handlers via Adapter . Registering and running http methods. This is the responsibility of Router . In general, the algorithm of route processing is as follows: Register the handler on the route using the Register method. Passing the handler to Adapter and receiving the same handler, but in a special wrapper. Adding the http method, path pattern and adapted handler to the route processing list. When url and path pattern match, the adapted handler will start.","title":"package router"},{"location":"router/router/#adapter","text":"The Adapter object is needed to adapt the handler to work with the rest of the framework modules. The object is also needed to control the handler in a more flexible way. In general, Adapter should wrap the passed handler to work with other modules, and then this wrapper will be launched in Router . The adapter's responsibilities include the following items: Clearing logs before running the handler Creating a new instance of the Manager object. Setting some Manager.OneTimeData variables Running all types of middleware Running the original handler Outputting request logs to the console","title":"Adapter"},{"location":"router/router/#adapteradapt","text":"This is the main method that wraps the source handler and thus runs all the necessary modules. In general, its implementation is quite simple, but there are a few nuances: Instead of http.ResponseWriter , BufferedResponseWriter is used. If the connection is a websocket, PostMiddlewares are not run","title":"Adapter.Adapt"},{"location":"router/router/#bufferedresponsewriter","text":"BufferedResponseWriter is a wrapper over http.ResponseWriter . The wrapper is needed to give more flexible control over how data is written to the page. This object fully implements the http.ResponseWriter interface, but the difference is that the Write method does not send the request immediately, but buffers it. To actually write the data you need to use the Flush method.","title":"BufferedResponseWriter"},{"location":"router/router/#bufferedresponsewriterflush","text":"A simple method that writes data to the original http.ResponseWriter . Accordingly, the data is sent immediately. func (rw *BufferedResponseWriter) Flush() (int, error) { for k, vv := range rw.header { for _, v := range vv { rw.original.Header().Add(k, v) } } rw.original.WriteHeader(rw.statusCode) return rw.original.Write(rw.buffer.Bytes()) }","title":"BufferedResponseWriter.Flush"},{"location":"router/router/#router","text":"The Router object is used to route http requests. The algorithm of its work looks like this: Obtaining the url address Searching for url address match in stored url templates Running a handler that is bound to the url template","title":"Router"},{"location":"router/router/#routerhandlerset","text":"Gegisters multiple handlers at once. Does everything the same as Router.Register , but only with multiple handlers. The method is just for convenience. Example Usage: newRouter.HandlerSet( map[string][]map[string]router.Handler{ router.MethodGET: { {\"/home\": homeHandler}, {\"/about\": aboutHandler}, }, router.MethodPOST: { {\"/register\": registerHandler}, }, } )","title":"Router.HandlerSet"},{"location":"router/router/#routerregister","text":"It simply registers a handler on the selected path. Uses Adapter to wrap the handler. newRouter.Register(router.MethodGET, \"/page\", func(w http.ResponseWriter, r *http.Request, manager interfaces.Manager) error { manager.Render().SetTemplatePath(\"index.html\") if err := manager.Render().RenderTemplate(w, r); err != nil { return err } return nil })","title":"Router.Register"},{"location":"router/router/#routerservehttp","text":"Implements the http.Handler interface. It is used to call handlers.","title":"Router.ServeHTTP"},{"location":"router/router/#redirecterror","text":"The function redirects to the selected url. Also, the url parameters are redirected with an error from the function arguments. func RedirectError(w http.ResponseWriter, r *http.Request, path string, _err string) { uval := url.Values{} uval.Add(namelib.ROUTER.REDIRECT_ERROR, _err) newUrl := fmt.Sprintf(\"%s?%s\", path, uval.Encode()) http.Redirect(w, r, newUrl, http.StatusFound) debug.ErrorLogginIfEnable(_err) debug.RequestLogginIfEnable(debug.P_ERROR, _err) }","title":"RedirectError"},{"location":"router/router/#catchredirecterror","text":"Catches an error from url parameters that is passed through the RedirectError function. Sets the error to the manager context. If there is a Render instance in Manager , sets the error to its context. Both contexts are handled by the namelib.ROUTER.REDIRECT_ERROR key. func CatchRedirectError(r *http.Request, manager interfaces.Manager) { q := r.URL.Query() redirectError := q.Get(namelib.ROUTER.REDIRECT_ERROR) if redirectError != \"\" { if manager.Render() != nil { manager.Render().SetContext(map[string]interface{}{namelib.ROUTER.REDIRECT_ERROR: redirectError}) } manager.OneTimeData().SetUserContext(namelib.ROUTER.REDIRECT_ERROR, redirectError) } }","title":"CatchRedirectError"},{"location":"router/router/#servererror","text":"Sends an error with code 500 and the text \"500 Internal server error\" to the page. The text is sent using the special function TODO: link debug.ErrorLoggingIfEnableAndWrite . func ServerError(w http.ResponseWriter, error string, manager interfaces.Manager) { manager.OneTimeData().SetUserContext(namelib.ROUTER.SERVER_ERROR, error) w.WriteHeader(http.StatusInternalServerError) if config.LoadedConfig().Default.Debug.Debug { debug.ErrorLoggingIfEnableAndWrite(w, error, error) } else { debug.ErrorLoggingIfEnableAndWrite(w, error, \"500 Internal server error\") } debug.RequestLogginIfEnable(debug.P_ERROR, error) }","title":"ServerError"},{"location":"router/router/#serverforbidden","text":"Sends an error with code 403 and text \"500 Internal server error\" to the page. The text is sent using the special function TODO: link debug.ErrorLoggingIfEnableAndWrite . func ServerForbidden(w http.ResponseWriter, manager interfaces.Manager) { manager.OneTimeData().SetUserContext(namelib.ROUTER.SERVER_FORBIDDEN_ERROR, \"403 forbidden\") w.WriteHeader(http.StatusForbidden) debug.ErrorLoggingIfEnableAndWrite(w, \"403 forbidden\", \"403 forbidden\") debug.RequestLogginIfEnable(debug.P_ERROR, \"403 forbidden\") }","title":"ServerForbidden"},{"location":"router/router/#sendjson","text":"Sends Json as a response to an http request. func SendJson(data interface{}, w http.ResponseWriter, code int) error { marshal, err := json.Marshal(data) if err != nil { return err } w.Header().Set(\"Content-Type\", \"application/json\") w.WriteHeader(code) _, err = w.Write(marshal) if err != nil { return err } return nil }","title":"SendJson"},{"location":"router/websocket/","text":"websocket Implementation of the websocket protocol. Uses the gorilla/websocket library. Used as a regular handler, for example: func Socket(w http.ResponseWriter, r *http.Request, manager interfaces.IManager) error { socket := router.NewWebsocket(router.Upgrader) socket.OnConnect(func(w http.ResponseWriter, r *http.Request, conn *websocket.Conn) { fmt.Println(\"Connect\") }) socket.OnClientClose(func(w http.ResponseWriter, r *http.Request, conn *websocket.Conn) { fmt.Println(\"Close\") }) socket.OnMessage(func(messageType int, msgData []byte, conn *websocket.Conn) { if err := conn.WriteMessage(messageType, msgData) { fmt.Println(\"Send message error:\", err) } }) // Start receive messages if err := socket.ReceiveMessages(w, r); err != nil { fmt.Println(\"Receive messages error:\", err) } return nil } NOTE: to start the websocket, you must run the method ReceiveMessages . Websocket object The object that handles the Websocket connection. To start working with Websocket, you need to initialize this object. socket := router.NewWebsocket(router.Upgrader) Websocket.OnConnect A handler that will be executed when the user connects to the Websocket. socket.OnConnect(func(w http.ResponseWriter, r *http.Request, conn *websocket.Conn) { fmt.Println(\"Connect\") }) Websocket.OnClientClose A handler that will be executed when the user disconnects from Websocket. socket.OnClientClose(func(w http.ResponseWriter, r *http.Request, conn *websocket.Conn) { fmt.Println(\"Close\") }) Websocket.OnMessage A handler that will be executed when a message is received from any connected user. messageType \u2014 message type msgData \u2014 message data conn \u2014 connection that sent the message socket.OnMessage(func(messageType int, msgData []byte, conn *websocket.Conn) { if err := conn.WriteMessage(messageType, msgData) { fmt.Println(\"Send message error:\", err) } }) Websocket.ReceiveMessages A method that listens to the websocket and receives messages from users. It is required to start the websocket. if err := socket.ReceiveMessages(w, r); err != nil { fmt.Println(\"Receive messages error:\", err) } WsSendTextMessage Sends a message to an open websocket. This function can be useful for testing or communicating with other websockets. IMPORTANT: This function creates a new connection each time, so it should not be used under high loads, as performance may be significantly reduced. func WsSendTextMessage(msg string, url string, header http.Header) (*http.Response, error) { dial, response, err := websocket.DefaultDialer.Dial(url, header) if err != nil { return response, err } err = dial.WriteMessage(websocket.TextMessage, []byte(msg)) if err != nil { return response, err } err = dial.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\")) if err != nil { return response, err } err = dial.Close() if err != nil { return response, err } return response, nil }","title":"Websocket"},{"location":"router/websocket/#websocket","text":"Implementation of the websocket protocol. Uses the gorilla/websocket library. Used as a regular handler, for example: func Socket(w http.ResponseWriter, r *http.Request, manager interfaces.IManager) error { socket := router.NewWebsocket(router.Upgrader) socket.OnConnect(func(w http.ResponseWriter, r *http.Request, conn *websocket.Conn) { fmt.Println(\"Connect\") }) socket.OnClientClose(func(w http.ResponseWriter, r *http.Request, conn *websocket.Conn) { fmt.Println(\"Close\") }) socket.OnMessage(func(messageType int, msgData []byte, conn *websocket.Conn) { if err := conn.WriteMessage(messageType, msgData) { fmt.Println(\"Send message error:\", err) } }) // Start receive messages if err := socket.ReceiveMessages(w, r); err != nil { fmt.Println(\"Receive messages error:\", err) } return nil } NOTE: to start the websocket, you must run the method ReceiveMessages .","title":"websocket"},{"location":"router/websocket/#websocket-object","text":"The object that handles the Websocket connection. To start working with Websocket, you need to initialize this object. socket := router.NewWebsocket(router.Upgrader)","title":"Websocket object"},{"location":"router/websocket/#websocketonconnect","text":"A handler that will be executed when the user connects to the Websocket. socket.OnConnect(func(w http.ResponseWriter, r *http.Request, conn *websocket.Conn) { fmt.Println(\"Connect\") })","title":"Websocket.OnConnect"},{"location":"router/websocket/#websocketonclientclose","text":"A handler that will be executed when the user disconnects from Websocket. socket.OnClientClose(func(w http.ResponseWriter, r *http.Request, conn *websocket.Conn) { fmt.Println(\"Close\") })","title":"Websocket.OnClientClose"},{"location":"router/websocket/#websocketonmessage","text":"A handler that will be executed when a message is received from any connected user. messageType \u2014 message type msgData \u2014 message data conn \u2014 connection that sent the message socket.OnMessage(func(messageType int, msgData []byte, conn *websocket.Conn) { if err := conn.WriteMessage(messageType, msgData) { fmt.Println(\"Send message error:\", err) } })","title":"Websocket.OnMessage"},{"location":"router/websocket/#websocketreceivemessages","text":"A method that listens to the websocket and receives messages from users. It is required to start the websocket. if err := socket.ReceiveMessages(w, r); err != nil { fmt.Println(\"Receive messages error:\", err) }","title":"Websocket.ReceiveMessages"},{"location":"router/websocket/#wssendtextmessage","text":"Sends a message to an open websocket. This function can be useful for testing or communicating with other websockets. IMPORTANT: This function creates a new connection each time, so it should not be used under high loads, as performance may be significantly reduced. func WsSendTextMessage(msg string, url string, header http.Header) (*http.Response, error) { dial, response, err := websocket.DefaultDialer.Dial(url, header) if err != nil { return response, err } err = dial.WriteMessage(websocket.TextMessage, []byte(msg)) if err != nil { return response, err } err = dial.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \"\")) if err != nil { return response, err } err = dial.Close() if err != nil { return response, err } return response, nil }","title":"WsSendTextMessage"},{"location":"router/cookies/cookies/","text":"Cookies The package contains various interactions with standard cookies. CreateSecureCookieData CreateSecureCookieData creates cookie data using encoding and HMAC. hashKey is responsible for HMAC, and blockKey is for encoding. func CreateSecureCookieData(hashKey []byte, blockKey []byte, w http.ResponseWriter, cookie *http.Cookie, cookieValue interface{}) error { secureValue, err := secure.CreateSecureData(hashKey, blockKey, cookieValue) if err != nil { return err } cookie.Value = secureValue http.SetCookie(w, cookie) return nil } ReadSecureCookieData ReadSecureCookieData reads data encoded with CreateSecureCookieData . hashKey is responsible for HMAC, and blockKey is for encoding. func ReadSecureCookieData(hashKey []byte, blockKey []byte, r *http.Request, name string, readCookie interface{}) error { cookie, err := r.Cookie(name) if err != nil { return err } if err := secure.ReadSecureData(hashKey, blockKey, cookie.Value, &readCookie); err != nil { return err } return nil } CreateSecureNoHMACCookieData Creates an encoding of the cookie data, but without HMAC. func CreateSecureNoHMACCookieData(key []byte, w http.ResponseWriter, cookie *http.Cookie, cookieValue interface{}) error { data, err := json.Marshal(cookieValue) if err != nil { return err } enc, err := secure.Encrypt(key, data) if err != nil { return err } cookie.Value = enc http.SetCookie(w, cookie) return nil } ReadSecureNoHMACCookieData Reads data that was encoded using CreateSecureNoHMACCookieData . func ReadSecureNoHMACCookieData(key []byte, r *http.Request, name string, readValue interface{}) error { cookie, err := r.Cookie(name) if err != nil { return err } dec, err := secure.Decrypt(key, cookie.Value) if err != nil { return err } if err := json.Unmarshal(dec, readValue); err != nil { return err } return nil } SetStandartCookie Just a handy feature for setting regular cookies. func SetStandartCookie(w http.ResponseWriter, name string, value string, path string, maxAge int) { cookie := &http.Cookie{ Name: name, Value: value, Path: path, MaxAge: maxAge, HttpOnly: true, Secure: true, } http.SetCookie(w, cookie) }","title":"Cookies"},{"location":"router/cookies/cookies/#cookies","text":"The package contains various interactions with standard cookies.","title":"Cookies"},{"location":"router/cookies/cookies/#createsecurecookiedata","text":"CreateSecureCookieData creates cookie data using encoding and HMAC. hashKey is responsible for HMAC, and blockKey is for encoding. func CreateSecureCookieData(hashKey []byte, blockKey []byte, w http.ResponseWriter, cookie *http.Cookie, cookieValue interface{}) error { secureValue, err := secure.CreateSecureData(hashKey, blockKey, cookieValue) if err != nil { return err } cookie.Value = secureValue http.SetCookie(w, cookie) return nil }","title":"CreateSecureCookieData"},{"location":"router/cookies/cookies/#readsecurecookiedata","text":"ReadSecureCookieData reads data encoded with CreateSecureCookieData . hashKey is responsible for HMAC, and blockKey is for encoding. func ReadSecureCookieData(hashKey []byte, blockKey []byte, r *http.Request, name string, readCookie interface{}) error { cookie, err := r.Cookie(name) if err != nil { return err } if err := secure.ReadSecureData(hashKey, blockKey, cookie.Value, &readCookie); err != nil { return err } return nil }","title":"ReadSecureCookieData"},{"location":"router/cookies/cookies/#createsecurenohmaccookiedata","text":"Creates an encoding of the cookie data, but without HMAC. func CreateSecureNoHMACCookieData(key []byte, w http.ResponseWriter, cookie *http.Cookie, cookieValue interface{}) error { data, err := json.Marshal(cookieValue) if err != nil { return err } enc, err := secure.Encrypt(key, data) if err != nil { return err } cookie.Value = enc http.SetCookie(w, cookie) return nil }","title":"CreateSecureNoHMACCookieData"},{"location":"router/cookies/cookies/#readsecurenohmaccookiedata","text":"Reads data that was encoded using CreateSecureNoHMACCookieData . func ReadSecureNoHMACCookieData(key []byte, r *http.Request, name string, readValue interface{}) error { cookie, err := r.Cookie(name) if err != nil { return err } dec, err := secure.Decrypt(key, cookie.Value) if err != nil { return err } if err := json.Unmarshal(dec, readValue); err != nil { return err } return nil }","title":"ReadSecureNoHMACCookieData"},{"location":"router/cookies/cookies/#setstandartcookie","text":"Just a handy feature for setting regular cookies. func SetStandartCookie(w http.ResponseWriter, name string, value string, path string, maxAge int) { cookie := &http.Cookie{ Name: name, Value: value, Path: path, MaxAge: maxAge, HttpOnly: true, Secure: true, } http.SetCookie(w, cookie) }","title":"SetStandartCookie"},{"location":"router/form/form/","text":"Form package A package for working with HTML forms. The package performs the following tasks: Parsing forms application/x-www-form-urlencoded and multipart/form-data . Sending different types of forms. Working with files. Example of use: func Handler(w http.ResponseWriter, r *http.Request, manager interfaces.IManager) error { frm := form.NewForm(r) if err := frm.Parse(); err != nil { return err } } FormFile FormFile representation of the form file as an object. All data of the file is stored here. type FormFile struct { Header *multipart.FileHeader } Form The Form object is designed to process forms. It parses application/x-www-form-urlencoded and multipart/form-data forms. Form.Parse Parses forms of types application/x-www-form-urlencoded and multipart/form-data , which are passed by *http.Request . func (f *Form) Parse() error { enctype := strings.Split(f.request.Header.Get(\"Content-Type\"), \";\")[0] switch enctype { case \"application/x-www-form-urlencoded\": err := f.request.ParseForm() if err != nil { return err } f.applicationForm = f.request.PostForm case \"multipart/form-data\": err := f.request.ParseMultipartForm(f.multipartMaxMemory) if err != nil { return err } f.multipartForm = f.request.MultipartForm } return nil } Form.GetMultipartForm Getting multipart/form-data form data. func (f *Form) GetMultipartForm() *multipart.Form { return f.multipartForm } Form.GetApplicationForm Getting multipart/form-data form data. func (f *Form) GetApplicationForm() netUrl.Values { return f.applicationForm } Form.Value Returns the value of the form by key. This can only be a simple value, a file cannot be returned here. func (f *Form) Value(key string) string { val := f.request.PostFormValue(key) return template.HTMLEscapeString(val) } Form.File Returns a file from a form by key. func (f *Form) File(key string) (multipart.File, *multipart.FileHeader, error) { return f.request.FormFile(key) } Form.File Returns multiple files from the form by key. func (f *Form) Files(key string) ([]*multipart.FileHeader, bool) { fi, ok := f.multipartForm.File[key] return fi, ok } SaveFile SaveFile Saves the file in the specified directory. If the file name is already found, uses the randomiseTheFileName function to randomise the file name. func SaveFile(fileHeader *multipart.FileHeader, pathToDir string, buildPath *string, manager interfaces.Manager) error ReplaceFile Changes the specified file to a new file. func ReplaceFile(pathToFile string, fileHeader *multipart.FileHeader, pathToDir string, buildPath *string, manager interfaces.Manager) error SendApplicationForm Sends a form of type application/x-www-form-urlencoded to the specified address. func SendApplicationForm(url string, values map[string][]string) (*http.Response, error) SendMultipartForm Sends a form of type multipart/form-data to the specified address. The files argument accepts form field names and a slice with file paths. func SendMultipartForm(url string, values map[string][]string, files map[string][]string) (*http.Response, error)","title":"Form"},{"location":"router/form/form/#form-package","text":"A package for working with HTML forms. The package performs the following tasks: Parsing forms application/x-www-form-urlencoded and multipart/form-data . Sending different types of forms. Working with files. Example of use: func Handler(w http.ResponseWriter, r *http.Request, manager interfaces.IManager) error { frm := form.NewForm(r) if err := frm.Parse(); err != nil { return err } }","title":"Form package"},{"location":"router/form/form/#formfile","text":"FormFile representation of the form file as an object. All data of the file is stored here. type FormFile struct { Header *multipart.FileHeader }","title":"FormFile"},{"location":"router/form/form/#form","text":"The Form object is designed to process forms. It parses application/x-www-form-urlencoded and multipart/form-data forms.","title":"Form"},{"location":"router/form/form/#formparse","text":"Parses forms of types application/x-www-form-urlencoded and multipart/form-data , which are passed by *http.Request . func (f *Form) Parse() error { enctype := strings.Split(f.request.Header.Get(\"Content-Type\"), \";\")[0] switch enctype { case \"application/x-www-form-urlencoded\": err := f.request.ParseForm() if err != nil { return err } f.applicationForm = f.request.PostForm case \"multipart/form-data\": err := f.request.ParseMultipartForm(f.multipartMaxMemory) if err != nil { return err } f.multipartForm = f.request.MultipartForm } return nil }","title":"Form.Parse"},{"location":"router/form/form/#formgetmultipartform","text":"Getting multipart/form-data form data. func (f *Form) GetMultipartForm() *multipart.Form { return f.multipartForm }","title":"Form.GetMultipartForm"},{"location":"router/form/form/#formgetapplicationform","text":"Getting multipart/form-data form data. func (f *Form) GetApplicationForm() netUrl.Values { return f.applicationForm }","title":"Form.GetApplicationForm"},{"location":"router/form/form/#formvalue","text":"Returns the value of the form by key. This can only be a simple value, a file cannot be returned here. func (f *Form) Value(key string) string { val := f.request.PostFormValue(key) return template.HTMLEscapeString(val) }","title":"Form.Value"},{"location":"router/form/form/#formfile_1","text":"Returns a file from a form by key. func (f *Form) File(key string) (multipart.File, *multipart.FileHeader, error) { return f.request.FormFile(key) }","title":"Form.File"},{"location":"router/form/form/#formfile_2","text":"Returns multiple files from the form by key. func (f *Form) Files(key string) ([]*multipart.FileHeader, bool) { fi, ok := f.multipartForm.File[key] return fi, ok }","title":"Form.File"},{"location":"router/form/form/#savefile","text":"SaveFile Saves the file in the specified directory. If the file name is already found, uses the randomiseTheFileName function to randomise the file name. func SaveFile(fileHeader *multipart.FileHeader, pathToDir string, buildPath *string, manager interfaces.Manager) error","title":"SaveFile"},{"location":"router/form/form/#replacefile","text":"Changes the specified file to a new file. func ReplaceFile(pathToFile string, fileHeader *multipart.FileHeader, pathToDir string, buildPath *string, manager interfaces.Manager) error","title":"ReplaceFile"},{"location":"router/form/form/#sendapplicationform","text":"Sends a form of type application/x-www-form-urlencoded to the specified address. func SendApplicationForm(url string, values map[string][]string) (*http.Response, error)","title":"SendApplicationForm"},{"location":"router/form/form/#sendmultipartform","text":"Sends a form of type multipart/form-data to the specified address. The files argument accepts form field names and a slice with file paths. func SendMultipartForm(url string, values map[string][]string, files map[string][]string) (*http.Response, error)","title":"SendMultipartForm"},{"location":"router/manager/manager/","text":"Manager The Manager object is used to manage router modules. The object's responsibilities include the following tasks: Transferring data within a single HTTP request. That is, data cannot be transferred between two HTTP requests Storing the Render object More convenient access to the TODO: link Key module Access to TODO: link DatabasePool Manager.New Creates a new instance of Manager with some of the old settings. This is a very important method because it creates a new instance of Manager , but retains the static data. If a new instance is created without this method, the router may not work properly or may cause serious problems. Also creates a new instance of Render if it has been set previously. func (m *Manager) New() (interface{}, error) { newOTD, err := m.oneTimeData.New() if err != nil { return nil, err } var newRender interfaces.Render if m.render != nil { _newRender, err := m.render.New() if err != nil { return nil, err } newRender = _newRender.(interfaces.Render) } return &Manager{ oneTimeData: newOTD.(interfaces.ManagerOneTimeData), render: newRender, key: m.key, databasePool: m.databasePool, }, nil } OneTimeData An object that transfers data between router modules. Data can only be transferred within the boundaries of a single HTTP request. For example, data cannot be transferred to another handler. For correct operation, a new instance of this object must be created in Adapter for each handler call. OneTimeData.SetSlugParams Sets slug parameters for further retrieval by the user. The setting is made inside adapter . func (m *OneTimeData) SetSlugParams(params map[string]string) { m.slugParams = params } OneTimeData.GetSlugParams Returns the slug parameter. func (m *OneTimeData) GetSlugParams(key string) (string, bool) { res, ok := m.slugParams[key] return res, ok } OneTimeData.SetUserContext Sets the user context. The user can then use this data. The framework automatically sets some data here, here is a list of it: namelib.ROUTER.URL_PATTERN \u2014 the current URL pattern. namelib.ROUTER.REDIRECT_ERROR \u2014 redirect error. Set only if the router.CatchRedirectError function is called. namelib.ROUTER.SERVER_ERROR \u2014 server error. Set only if the router.ServerError function is called. namelib.ROUTER.SERVER_FORBIDDEN_ERROR \u2014 access error. Set only if the router.ServerForbidden function is called. namelib.ROUTER.SKIP_NEXT_PAGE \u2014 tells the router to skip the page handler. Set only if the TODO: link middlewares.SkipNextPage function is called. namelib.OBJECT.OBJECT_CONTEXT \u2014 object that is filled in TODO: link view . namelib.ROUTER.COOKIE_CSRF_TOKEN \u2014 html string with CSRF token. Set only if the TODO: link secure.SetCSRFToken function is called. func (m *OneTimeData) SetUserContext(key string, value interface{}) { m.userContext.Store(key, value) } OneTimeData.GetUserContext Returns the user context. func (m *OneTimeData) GetUserContext(key string) (any, bool) { m.userContext.Range(func(key, value any) bool { return true }) value, ok := m.userContext.Load(key) return value, ok } OneTimeData.DelUserContext Removes user context. func (m *OneTimeData) DelUserContext(key string) { m.userContext.Delete(key) }","title":"Manager"},{"location":"router/manager/manager/#manager","text":"The Manager object is used to manage router modules. The object's responsibilities include the following tasks: Transferring data within a single HTTP request. That is, data cannot be transferred between two HTTP requests Storing the Render object More convenient access to the TODO: link Key module Access to TODO: link DatabasePool","title":"Manager"},{"location":"router/manager/manager/#managernew","text":"Creates a new instance of Manager with some of the old settings. This is a very important method because it creates a new instance of Manager , but retains the static data. If a new instance is created without this method, the router may not work properly or may cause serious problems. Also creates a new instance of Render if it has been set previously. func (m *Manager) New() (interface{}, error) { newOTD, err := m.oneTimeData.New() if err != nil { return nil, err } var newRender interfaces.Render if m.render != nil { _newRender, err := m.render.New() if err != nil { return nil, err } newRender = _newRender.(interfaces.Render) } return &Manager{ oneTimeData: newOTD.(interfaces.ManagerOneTimeData), render: newRender, key: m.key, databasePool: m.databasePool, }, nil }","title":"Manager.New"},{"location":"router/manager/manager/#onetimedata","text":"An object that transfers data between router modules. Data can only be transferred within the boundaries of a single HTTP request. For example, data cannot be transferred to another handler. For correct operation, a new instance of this object must be created in Adapter for each handler call.","title":"OneTimeData"},{"location":"router/manager/manager/#onetimedatasetslugparams","text":"Sets slug parameters for further retrieval by the user. The setting is made inside adapter . func (m *OneTimeData) SetSlugParams(params map[string]string) { m.slugParams = params }","title":"OneTimeData.SetSlugParams"},{"location":"router/manager/manager/#onetimedatagetslugparams","text":"Returns the slug parameter. func (m *OneTimeData) GetSlugParams(key string) (string, bool) { res, ok := m.slugParams[key] return res, ok }","title":"OneTimeData.GetSlugParams"},{"location":"router/manager/manager/#onetimedatasetusercontext","text":"Sets the user context. The user can then use this data. The framework automatically sets some data here, here is a list of it: namelib.ROUTER.URL_PATTERN \u2014 the current URL pattern. namelib.ROUTER.REDIRECT_ERROR \u2014 redirect error. Set only if the router.CatchRedirectError function is called. namelib.ROUTER.SERVER_ERROR \u2014 server error. Set only if the router.ServerError function is called. namelib.ROUTER.SERVER_FORBIDDEN_ERROR \u2014 access error. Set only if the router.ServerForbidden function is called. namelib.ROUTER.SKIP_NEXT_PAGE \u2014 tells the router to skip the page handler. Set only if the TODO: link middlewares.SkipNextPage function is called. namelib.OBJECT.OBJECT_CONTEXT \u2014 object that is filled in TODO: link view . namelib.ROUTER.COOKIE_CSRF_TOKEN \u2014 html string with CSRF token. Set only if the TODO: link secure.SetCSRFToken function is called. func (m *OneTimeData) SetUserContext(key string, value interface{}) { m.userContext.Store(key, value) }","title":"OneTimeData.SetUserContext"},{"location":"router/manager/manager/#onetimedatagetusercontext","text":"Returns the user context. func (m *OneTimeData) GetUserContext(key string) (any, bool) { m.userContext.Range(func(key, value any) bool { return true }) value, ok := m.userContext.Load(key) return value, ok }","title":"OneTimeData.GetUserContext"},{"location":"router/manager/manager/#onetimedatadelusercontext","text":"Removes user context. func (m *OneTimeData) DelUserContext(key string) { m.userContext.Delete(key) }","title":"OneTimeData.DelUserContext"},{"location":"router/middlewares/middlewares/","text":"package middlewares This package implements middleware. Middleware is software that acts as a bridge between applications, operating systems, and other software components, providing common services and capabilities. Example of use: mdd := middlewares.NewMiddlewares() mdd.PreMiddleware(0, func(w http.ResponseWriter, r *http.Request, m interfaces.Manager) error { fmt.Println(\"PRE\") return nil }) mdd.AsyncMiddleware(func(w http.ResponseWriter, r *http.Request, m interfaces.Manager) error { fmt.Println(\"ASYNC\") return nil }) mdd.AsyncMiddleware(func(w http.ResponseWriter, r *http.Request, m interfaces.Manager) error { fmt.Println(\"ASYNC 2\") return nil }) mdd.PostMiddleware(0, func(r *http.Request, m interfaces.Manager) error { fmt.Println(\"POST\") return nil }) adapter := router.NewAdapter(newManager, mdd) NOTE: you must install middlewares in the adapter . adapter := router.NewAdapter(newManager, mdd) Middlewares Middlewares implementation of the middleware concept for the framework. Three types of middleware are possible: PreMiddleware \u2014 executed synchronously before the request. These middlewares are executed exactly according to their established order. PostMiddleware \u2014 executed synchronously after the request. These middlewares will be called in the specified order. AsyncMiddleware \u2014 asynchronous middleware. They are executed asynchronously, but after PreMiddleware and before the request handler. Cannot be ordered, so are not used in a chain. Also each middleware returns an error, it is handled in the router. But if you need more specific processing, you can not return an error, but process it directly in the middleware. Also very important point: there are also functions that can control the router from middleware, they are in the same package. These functions should be called only in middleware. These functions include: SkipNextPage \u2014 skips the page turner. That is, not just its display, but the whole logic. SkipNextPageAndRedirect \u2014 does the same thing as SkipNextPage , but does redirect after skipping the page. Middlewares.PreMiddleware Middleware that are executed in an ordered fashion before the url handler. The order must not be repeated. func (mddl *Middlewares) PreMiddleware(order int, handler PreMiddleware) { if slices.Contains(mddl.preMiddlewaresOrder, order) { panic(fmt.Sprintf(\"middleware with order %s already exists\", strconv.Itoa(order))) } mddl.preMiddlewaresOrder = append(mddl.preMiddlewaresOrder, order) mddl.preMiddlewares[order] = handler } Middlewares.PostMiddleware Middleware that runs after the HTTP request handler has been confirmed. func (mddl *Middlewares) PostMiddleware(order int, handler PostMiddleware) { if slices.Contains(mddl.postMiddlewaresOrder, order) { panic(fmt.Sprintf(\"middleware with order %s already exists\", strconv.Itoa(order))) } mddl.postMiddlewaresOrder = append(mddl.postMiddlewaresOrder, order) mddl.postMiddlewares[order] = handler } Middlewares.AsyncMiddleware Middleware that is executed asynchronously before the request handler, but after PreMiddleware processing. Can't create chains, not called in an orderly fashion. func (mddl *Middlewares) AsyncMiddleware(handler AsyncMiddleware) { mddl.asyncMiddlewares = append(mddl.asyncMiddlewares, handler) } Middlewares.RunPreMiddlewares Runs all PreMiddleware . Starts them in sorted order, i.e. 1...n. func (mddl *Middlewares) RunPreMiddlewares(w http.ResponseWriter, r *http.Request, m interfaces.Manager) error { mddl.preMiddlewaresOrder.Sort() for i := 0; i < mddl.preMiddlewaresOrder.Len(); i++ { order := mddl.preMiddlewaresOrder[i] if err := mddl.preMiddlewares[order](w, r, m); err != nil { return err } } return nil } Middlewares. RunAndWaitAsyncMiddlewares Runs asynchronous middlewares. It also waits for them to complete, no additional actions are needed. If at least one middleware causes an error, all handlers stop. func (mddl *Middlewares) RunAndWaitAsyncMiddlewares(w http.ResponseWriter, r *http.Request, m interfaces.Manager) error { var wg sync.WaitGroup var asyncError error var mu sync.Mutex stop := make(chan struct{}) for i := 0; i < len(mddl.asyncMiddlewares); i++ { handler := mddl.asyncMiddlewares[i] wg.Add(1) go func(h AsyncMiddleware) { defer wg.Done() // If at least one handler causes an error, all other handlers will fail to run. select { case <-stop: return default: } if err := h(w, r, m); err != nil { mu.Lock() asyncError = err close(stop) mu.Unlock() } }(handler) } wg.Wait() return asyncError } Middlewares.RunPostMiddlewares Runs all PostMiddleware . Starts them in sorted order, i.e. 1...n. func (mddl *Middlewares) RunPostMiddlewares(r *http.Request, m interfaces.Manager) error { mddl.postMiddlewaresOrder.Sort() for i := 0; i < mddl.postMiddlewaresOrder.Len(); i++ { order := mddl.postMiddlewaresOrder[i] if err := mddl.postMiddlewares[order](r, m); err != nil { return err } } return nil } SkipNextPage Sends a command to the router to skip rendering the next page. func SkipNextPage(manager interfaces.ManagerOneTimeData) { manager.SetUserContext(namelib.ROUTER.SKIP_NEXT_PAGE, true) urlPattern, _ := manager.GetUserContext(namelib.ROUTER.URL_PATTERN) debug.RequestLogginIfEnable(debug.P_MIDDLEWARE, fmt.Sprintf(\"skip page at %s\", urlPattern)) } IsSkipNextPage Checks if the page rendering should be skipped. The function is built into the router . func IsSkipNextPage(manager interfaces.ManagerOneTimeData) bool { _, ok := manager.GetUserContext(namelib.ROUTER.SKIP_NEXT_PAGE) return ok } SkipNextPageAndRedirect Skips the page render and redirects to another page. func SkipNextPageAndRedirect(manager interfaces.ManagerOneTimeData, w http.ResponseWriter, r *http.Request, path string) { http.Redirect(w, r, path, http.StatusFound) SkipNextPage(manager) debug.RequestLogginIfEnable(debug.P_MIDDLEWARE, fmt.Sprintf(\"redirect to %s\", path)) }","title":"Middlewares"},{"location":"router/middlewares/middlewares/#package-middlewares","text":"This package implements middleware. Middleware is software that acts as a bridge between applications, operating systems, and other software components, providing common services and capabilities. Example of use: mdd := middlewares.NewMiddlewares() mdd.PreMiddleware(0, func(w http.ResponseWriter, r *http.Request, m interfaces.Manager) error { fmt.Println(\"PRE\") return nil }) mdd.AsyncMiddleware(func(w http.ResponseWriter, r *http.Request, m interfaces.Manager) error { fmt.Println(\"ASYNC\") return nil }) mdd.AsyncMiddleware(func(w http.ResponseWriter, r *http.Request, m interfaces.Manager) error { fmt.Println(\"ASYNC 2\") return nil }) mdd.PostMiddleware(0, func(r *http.Request, m interfaces.Manager) error { fmt.Println(\"POST\") return nil }) adapter := router.NewAdapter(newManager, mdd) NOTE: you must install middlewares in the adapter . adapter := router.NewAdapter(newManager, mdd)","title":"package middlewares"},{"location":"router/middlewares/middlewares/#middlewares","text":"Middlewares implementation of the middleware concept for the framework. Three types of middleware are possible: PreMiddleware \u2014 executed synchronously before the request. These middlewares are executed exactly according to their established order. PostMiddleware \u2014 executed synchronously after the request. These middlewares will be called in the specified order. AsyncMiddleware \u2014 asynchronous middleware. They are executed asynchronously, but after PreMiddleware and before the request handler. Cannot be ordered, so are not used in a chain. Also each middleware returns an error, it is handled in the router. But if you need more specific processing, you can not return an error, but process it directly in the middleware. Also very important point: there are also functions that can control the router from middleware, they are in the same package. These functions should be called only in middleware. These functions include: SkipNextPage \u2014 skips the page turner. That is, not just its display, but the whole logic. SkipNextPageAndRedirect \u2014 does the same thing as SkipNextPage , but does redirect after skipping the page.","title":"Middlewares"},{"location":"router/middlewares/middlewares/#middlewarespremiddleware","text":"Middleware that are executed in an ordered fashion before the url handler. The order must not be repeated. func (mddl *Middlewares) PreMiddleware(order int, handler PreMiddleware) { if slices.Contains(mddl.preMiddlewaresOrder, order) { panic(fmt.Sprintf(\"middleware with order %s already exists\", strconv.Itoa(order))) } mddl.preMiddlewaresOrder = append(mddl.preMiddlewaresOrder, order) mddl.preMiddlewares[order] = handler }","title":"Middlewares.PreMiddleware"},{"location":"router/middlewares/middlewares/#middlewarespostmiddleware","text":"Middleware that runs after the HTTP request handler has been confirmed. func (mddl *Middlewares) PostMiddleware(order int, handler PostMiddleware) { if slices.Contains(mddl.postMiddlewaresOrder, order) { panic(fmt.Sprintf(\"middleware with order %s already exists\", strconv.Itoa(order))) } mddl.postMiddlewaresOrder = append(mddl.postMiddlewaresOrder, order) mddl.postMiddlewares[order] = handler }","title":"Middlewares.PostMiddleware"},{"location":"router/middlewares/middlewares/#middlewaresasyncmiddleware","text":"Middleware that is executed asynchronously before the request handler, but after PreMiddleware processing. Can't create chains, not called in an orderly fashion. func (mddl *Middlewares) AsyncMiddleware(handler AsyncMiddleware) { mddl.asyncMiddlewares = append(mddl.asyncMiddlewares, handler) }","title":"Middlewares.AsyncMiddleware"},{"location":"router/middlewares/middlewares/#middlewaresrunpremiddlewares","text":"Runs all PreMiddleware . Starts them in sorted order, i.e. 1...n. func (mddl *Middlewares) RunPreMiddlewares(w http.ResponseWriter, r *http.Request, m interfaces.Manager) error { mddl.preMiddlewaresOrder.Sort() for i := 0; i < mddl.preMiddlewaresOrder.Len(); i++ { order := mddl.preMiddlewaresOrder[i] if err := mddl.preMiddlewares[order](w, r, m); err != nil { return err } } return nil }","title":"Middlewares.RunPreMiddlewares"},{"location":"router/middlewares/middlewares/#middlewares-runandwaitasyncmiddlewares","text":"Runs asynchronous middlewares. It also waits for them to complete, no additional actions are needed. If at least one middleware causes an error, all handlers stop. func (mddl *Middlewares) RunAndWaitAsyncMiddlewares(w http.ResponseWriter, r *http.Request, m interfaces.Manager) error { var wg sync.WaitGroup var asyncError error var mu sync.Mutex stop := make(chan struct{}) for i := 0; i < len(mddl.asyncMiddlewares); i++ { handler := mddl.asyncMiddlewares[i] wg.Add(1) go func(h AsyncMiddleware) { defer wg.Done() // If at least one handler causes an error, all other handlers will fail to run. select { case <-stop: return default: } if err := h(w, r, m); err != nil { mu.Lock() asyncError = err close(stop) mu.Unlock() } }(handler) } wg.Wait() return asyncError }","title":"Middlewares. RunAndWaitAsyncMiddlewares"},{"location":"router/middlewares/middlewares/#middlewaresrunpostmiddlewares","text":"Runs all PostMiddleware . Starts them in sorted order, i.e. 1...n. func (mddl *Middlewares) RunPostMiddlewares(r *http.Request, m interfaces.Manager) error { mddl.postMiddlewaresOrder.Sort() for i := 0; i < mddl.postMiddlewaresOrder.Len(); i++ { order := mddl.postMiddlewaresOrder[i] if err := mddl.postMiddlewares[order](r, m); err != nil { return err } } return nil }","title":"Middlewares.RunPostMiddlewares"},{"location":"router/middlewares/middlewares/#skipnextpage","text":"Sends a command to the router to skip rendering the next page. func SkipNextPage(manager interfaces.ManagerOneTimeData) { manager.SetUserContext(namelib.ROUTER.SKIP_NEXT_PAGE, true) urlPattern, _ := manager.GetUserContext(namelib.ROUTER.URL_PATTERN) debug.RequestLogginIfEnable(debug.P_MIDDLEWARE, fmt.Sprintf(\"skip page at %s\", urlPattern)) }","title":"SkipNextPage"},{"location":"router/middlewares/middlewares/#isskipnextpage","text":"Checks if the page rendering should be skipped. The function is built into the router . func IsSkipNextPage(manager interfaces.ManagerOneTimeData) bool { _, ok := manager.GetUserContext(namelib.ROUTER.SKIP_NEXT_PAGE) return ok }","title":"IsSkipNextPage"},{"location":"router/middlewares/middlewares/#skipnextpageandredirect","text":"Skips the page render and redirects to another page. func SkipNextPageAndRedirect(manager interfaces.ManagerOneTimeData, w http.ResponseWriter, r *http.Request, path string) { http.Redirect(w, r, path, http.StatusFound) SkipNextPage(manager) debug.RequestLogginIfEnable(debug.P_MIDDLEWARE, fmt.Sprintf(\"redirect to %s\", path)) }","title":"SkipNextPageAndRedirect"},{"location":"router/object/object/","text":"object This package is designed to display data more conveniently on the page using view. More detailed use of this package is shown in the tests . IView The interface implements the basic structure of any IView. ITemplateView is used to display HTML page in a simpler and more convenient way. For the view to work correctly, you need to create a new structure (for example MyObjView), embed a ready-made implementation of the view (for example ObjView) into it, then you need to initialize this structure in the ITemplateView field in the TemplateView data type. type IView interface { // Object receives data from the selected table and writes it to a variable structure. // IMPORTANT: connects to the database in this method (or others), but closes the connection only in the TemplateView. Object(w http.ResponseWriter, r *http.Request, manager interfaces.Manager) (Context, error) Context(w http.ResponseWriter, r *http.Request, manager interfaces.Manager) (Context, error) Permissions(w http.ResponseWriter, r *http.Request, manager interfaces.Manager) (bool, func()) OnError(w http.ResponseWriter, r *http.Request, manager interfaces.Manager, err error) ObjectsName() []string } IViewDatabase Interface that provides object unified access to the database. Since each object queries the database, it is necessary to unify access to the database so as not to be dependent on a particular database. type IViewDatabase interface { // SelectAll selects all data from the table. SelectAll(tableName string) ([]map[string]interface{}, error) // SelectWhereEqual selects all data from the table according to the specified condition. SelectWhereEqual(tableName string, colName string, val any) ([]map[string]interface{}, error) } GetContext Retrieves the Context from the manager. It is important to understand that this method can only be used when the IView.Object method has completed running, for example in IView.Context . func GetContext(manager interfaces.Manager) (Context, error) { objectInterface, ok := manager.OneTimeData().GetUserContext(namelib.OBJECT.OBJECT_CONTEXT) if !ok { return nil, errors.New(\"unable to get object context\") } object := objectInterface.(Context) return object, nil } AllView Displays HTML page by passing all data from the selected table to it. If the slug parameter is set, all data from the table that match the condition will be output. If the slug parameter is not set, all data from the table will be output. type AllView struct { BaseView Name string `notdef:\"true\"` TableName string `notdef:\"true\"` Database IViewDatabase `notdef:\"true\"` Slug string FillStruct interface{} `notdef:\"true\"` } FormView This object is designed to process forms sent via HTML forms. type FormView struct { BaseView FormStruct interface{} `notdef:\"true\"` ValidateCSRF bool } FormInterface Retrieves the form interface itself from the interface pointer. func (v *FormView) FormInterface(manager interfaces.ManagerOneTimeData) (interface{}, error) { context, ok := manager.GetUserContext(namelib.OBJECT.OBJECT_CONTEXT) if !ok { return nil, errors.New(\"the ObjectContext not found\") } objectContext, ok := context.(Context) if !ok { return nil, errors.New(\"the ObjectContext type assertion error\") } return reflect.Indirect(reflect.ValueOf(objectContext[namelib.OBJECT.OBJECT_CONTEXT_FORM])).Interface(), nil } MultipleObjectView Used to display data from multiple sources at once. You also need to use MultipleObject to transfer data about a specific object. type MultipleObjectView struct { BaseView Database IViewDatabase `notdef:\"true\"` MultipleObjects []MultipleObject `notdef:\"true\"` } ObjView Displays only the HTML page only with a specific row from the database. Needs to be used with slug parameter URL path, specify the name of the parameter in the Slug parameter. type ObjView struct { BaseView Name string `notdef:\"true\"` TableName string `notdef:\"true\"` Database IViewDatabase `notdef:\"true\"` FillStruct interface{} `notdef:\"true\"` Slug string `notdef:\"true\"` } TemplateView Renders an HTML page using a template engine and View . type TemplateView struct { TemplatePath string View IView isSkipRender bool } TemplateRedirectView Renders an HTML page using a template engine and View . Redirects the page to the selected address. type TemplateRedirectView struct { View IView RedirectUrl string } JsonObjectTemplateView Function used to display ObjectView as JSON data. If the Messages field is empty, it renders JSON as a regular TemplateView . type JsonObjectTemplateView struct { View IView DTO *rest.DTO Message irest.Message onMessageFilled OnMessageFilled } JsonMultipleObjectTemplateView Function used to display MultipleObjectView as JSON data. If the Messages field is empty, it renders JSON as a regular TemplateView . type JsonMultipleObjectTemplateView struct { View IView DTO *rest.DTO Messages map[string]irest.Message onMessageFilled OnMessageFilled } JsonAllTemplateView Function used to display AllView as JSON data. If the Messages field is empty, it renders JSON as a regular TemplateView . type JsonAllTemplateView struct { View IView DTO *rest.DTO Message irest.Message onMessageFilled OnMessageFilled }","title":"Object"},{"location":"router/object/object/#object","text":"This package is designed to display data more conveniently on the page using view. More detailed use of this package is shown in the tests .","title":"object"},{"location":"router/object/object/#iview","text":"The interface implements the basic structure of any IView. ITemplateView is used to display HTML page in a simpler and more convenient way. For the view to work correctly, you need to create a new structure (for example MyObjView), embed a ready-made implementation of the view (for example ObjView) into it, then you need to initialize this structure in the ITemplateView field in the TemplateView data type. type IView interface { // Object receives data from the selected table and writes it to a variable structure. // IMPORTANT: connects to the database in this method (or others), but closes the connection only in the TemplateView. Object(w http.ResponseWriter, r *http.Request, manager interfaces.Manager) (Context, error) Context(w http.ResponseWriter, r *http.Request, manager interfaces.Manager) (Context, error) Permissions(w http.ResponseWriter, r *http.Request, manager interfaces.Manager) (bool, func()) OnError(w http.ResponseWriter, r *http.Request, manager interfaces.Manager, err error) ObjectsName() []string }","title":"IView"},{"location":"router/object/object/#iviewdatabase","text":"Interface that provides object unified access to the database. Since each object queries the database, it is necessary to unify access to the database so as not to be dependent on a particular database. type IViewDatabase interface { // SelectAll selects all data from the table. SelectAll(tableName string) ([]map[string]interface{}, error) // SelectWhereEqual selects all data from the table according to the specified condition. SelectWhereEqual(tableName string, colName string, val any) ([]map[string]interface{}, error) }","title":"IViewDatabase"},{"location":"router/object/object/#getcontext","text":"Retrieves the Context from the manager. It is important to understand that this method can only be used when the IView.Object method has completed running, for example in IView.Context . func GetContext(manager interfaces.Manager) (Context, error) { objectInterface, ok := manager.OneTimeData().GetUserContext(namelib.OBJECT.OBJECT_CONTEXT) if !ok { return nil, errors.New(\"unable to get object context\") } object := objectInterface.(Context) return object, nil }","title":"GetContext"},{"location":"router/object/object/#allview","text":"Displays HTML page by passing all data from the selected table to it. If the slug parameter is set, all data from the table that match the condition will be output. If the slug parameter is not set, all data from the table will be output. type AllView struct { BaseView Name string `notdef:\"true\"` TableName string `notdef:\"true\"` Database IViewDatabase `notdef:\"true\"` Slug string FillStruct interface{} `notdef:\"true\"` }","title":"AllView"},{"location":"router/object/object/#formview","text":"This object is designed to process forms sent via HTML forms. type FormView struct { BaseView FormStruct interface{} `notdef:\"true\"` ValidateCSRF bool }","title":"FormView"},{"location":"router/object/object/#forminterface","text":"Retrieves the form interface itself from the interface pointer. func (v *FormView) FormInterface(manager interfaces.ManagerOneTimeData) (interface{}, error) { context, ok := manager.GetUserContext(namelib.OBJECT.OBJECT_CONTEXT) if !ok { return nil, errors.New(\"the ObjectContext not found\") } objectContext, ok := context.(Context) if !ok { return nil, errors.New(\"the ObjectContext type assertion error\") } return reflect.Indirect(reflect.ValueOf(objectContext[namelib.OBJECT.OBJECT_CONTEXT_FORM])).Interface(), nil }","title":"FormInterface"},{"location":"router/object/object/#multipleobjectview","text":"Used to display data from multiple sources at once. You also need to use MultipleObject to transfer data about a specific object. type MultipleObjectView struct { BaseView Database IViewDatabase `notdef:\"true\"` MultipleObjects []MultipleObject `notdef:\"true\"` }","title":"MultipleObjectView"},{"location":"router/object/object/#objview","text":"Displays only the HTML page only with a specific row from the database. Needs to be used with slug parameter URL path, specify the name of the parameter in the Slug parameter. type ObjView struct { BaseView Name string `notdef:\"true\"` TableName string `notdef:\"true\"` Database IViewDatabase `notdef:\"true\"` FillStruct interface{} `notdef:\"true\"` Slug string `notdef:\"true\"` }","title":"ObjView"},{"location":"router/object/object/#templateview","text":"Renders an HTML page using a template engine and View . type TemplateView struct { TemplatePath string View IView isSkipRender bool }","title":"TemplateView"},{"location":"router/object/object/#templateredirectview","text":"Renders an HTML page using a template engine and View . Redirects the page to the selected address. type TemplateRedirectView struct { View IView RedirectUrl string }","title":"TemplateRedirectView"},{"location":"router/object/object/#jsonobjecttemplateview","text":"Function used to display ObjectView as JSON data. If the Messages field is empty, it renders JSON as a regular TemplateView . type JsonObjectTemplateView struct { View IView DTO *rest.DTO Message irest.Message onMessageFilled OnMessageFilled }","title":"JsonObjectTemplateView"},{"location":"router/object/object/#jsonmultipleobjecttemplateview","text":"Function used to display MultipleObjectView as JSON data. If the Messages field is empty, it renders JSON as a regular TemplateView . type JsonMultipleObjectTemplateView struct { View IView DTO *rest.DTO Messages map[string]irest.Message onMessageFilled OnMessageFilled }","title":"JsonMultipleObjectTemplateView"},{"location":"router/object/object/#jsonalltemplateview","text":"Function used to display AllView as JSON data. If the Messages field is empty, it renders JSON as a regular TemplateView . type JsonAllTemplateView struct { View IView DTO *rest.DTO Message irest.Message onMessageFilled OnMessageFilled }","title":"JsonAllTemplateView"},{"location":"router/rest/rest/","text":"dto The DTO system is an implementation of REST API with some special features. The purpose of DTO is to control and type the messages being sent. To make interaction with the client more convenient, you can use TypeScript interface generation. It works as follows: A message (structure) is created that controls the type of data being received and sent. All messages are registered. Optional . TypeScript interfaces are generated that correspond to the server message (structure). Messages are sent or received using special functions and methods. Example of use in these tests . DTO DTO (Data Transfer Object) generates a typescript interface using a message. For proper operation, you must make sure that the allowed messages match the transferred messages. IMPORTANT : Allowed messages [AllowedMessages] must be exactly the same as the messages to generate [Messages]. This is only needed during genaration. If no generation is taking place, you can use the allowed [AllowedMessages] alone. Any dependencies must also be included in the allowed messages, and they must be in the same file as the parent object. Importing from other files is not allowed. Structure fields must have the dto:\u201c<field_name>\u201d tag for successful generation. Where <field_name> is the name of the field in the typescript interface. If the tag is not added, the field will simply be skipped during generation. type DTO struct { allowedMessages []AllowMessage messages map[string][]irest.Message isGenerated bool } DTO.AllowedMessages List of allowed messages for generation. These messages will be checked before using the message, if it is not in this list, an error will be raised. func (d *DTO) AllowedMessages(messages []AllowMessage) { d.allowedMessages = messages } DTO.GetAllowedMessages Return []AllowMessage . func (d *DTO) GetAllowedMessages() []AllowMessage { return d.allowedMessages } DTO.Messages A list of messages that will be used for generation. So will check the generation allowances for each message. func (d *DTO) Messages(messages map[string][]irest.Message) { d.messages = messages } DTO.Generate Start of generation. Uses a template to generate typescript interfaces. func (d *DTO) Generate() error { if d.isGenerated { return ErrMultipleGenerateCall{} } if err := d.validateMessageIntegrity(); err != nil { return err } if err := d.writeClientMessages(); err != nil { return err } d.isGenerated = true return nil } ImplementDTOMessage Structure to be embedded in a message. Once inlined, the framework will implement the irest.IMessage interface. type ImplementDTOMessage struct{} AllowMessage Used to transmit packet data and message name in string type. type AllowMessage struct { Package string Name string } AllowMessage.FullName Outputs the full name of the message. For example: main.Message. func (a *AllowMessage) FullName() string { return fmt.Sprintf(\"%s.%s\", a.Package, a.Name) } IsSafeMessage Checks whether the message is safe. A message is safe if it is in allowed messages. func IsSafeMessage(message typeopr.IPtr, allowedMessages []AllowMessage) error { _type := reflect.TypeOf(message.Ptr()).Elem() if !typeopr.IsImplementInterface(message, (*irest.Message)(nil)) { return fmt.Errorf(\"%s message does not implement irest.IMessage interface\", _type) } // If the message type is passed through the irest.IMessage interface. if _type == reflect.TypeOf((*irest.Message)(nil)).Elem() { _type = reflect.TypeOf(reflect.ValueOf(message.Ptr()).Elem().Interface()) } pkgAndName := strings.Split(_type.String(), \".\") msg := AllowMessage{Package: pkgAndName[0], Name: pkgAndName[1]} if !fslice.SliceContains(allowedMessages, msg) { return fmt.Errorf(\"%s message is unsafe\", msg.FullName()) } return nil }","title":"Rest"},{"location":"router/rest/rest/#dto","text":"The DTO system is an implementation of REST API with some special features. The purpose of DTO is to control and type the messages being sent. To make interaction with the client more convenient, you can use TypeScript interface generation. It works as follows: A message (structure) is created that controls the type of data being received and sent. All messages are registered. Optional . TypeScript interfaces are generated that correspond to the server message (structure). Messages are sent or received using special functions and methods. Example of use in these tests .","title":"dto"},{"location":"router/rest/rest/#dto_1","text":"DTO (Data Transfer Object) generates a typescript interface using a message. For proper operation, you must make sure that the allowed messages match the transferred messages. IMPORTANT : Allowed messages [AllowedMessages] must be exactly the same as the messages to generate [Messages]. This is only needed during genaration. If no generation is taking place, you can use the allowed [AllowedMessages] alone. Any dependencies must also be included in the allowed messages, and they must be in the same file as the parent object. Importing from other files is not allowed. Structure fields must have the dto:\u201c<field_name>\u201d tag for successful generation. Where <field_name> is the name of the field in the typescript interface. If the tag is not added, the field will simply be skipped during generation. type DTO struct { allowedMessages []AllowMessage messages map[string][]irest.Message isGenerated bool }","title":"DTO"},{"location":"router/rest/rest/#dtoallowedmessages","text":"List of allowed messages for generation. These messages will be checked before using the message, if it is not in this list, an error will be raised. func (d *DTO) AllowedMessages(messages []AllowMessage) { d.allowedMessages = messages }","title":"DTO.AllowedMessages"},{"location":"router/rest/rest/#dtogetallowedmessages","text":"Return []AllowMessage . func (d *DTO) GetAllowedMessages() []AllowMessage { return d.allowedMessages }","title":"DTO.GetAllowedMessages"},{"location":"router/rest/rest/#dtomessages","text":"A list of messages that will be used for generation. So will check the generation allowances for each message. func (d *DTO) Messages(messages map[string][]irest.Message) { d.messages = messages }","title":"DTO.Messages"},{"location":"router/rest/rest/#dtogenerate","text":"Start of generation. Uses a template to generate typescript interfaces. func (d *DTO) Generate() error { if d.isGenerated { return ErrMultipleGenerateCall{} } if err := d.validateMessageIntegrity(); err != nil { return err } if err := d.writeClientMessages(); err != nil { return err } d.isGenerated = true return nil }","title":"DTO.Generate"},{"location":"router/rest/rest/#implementdtomessage","text":"Structure to be embedded in a message. Once inlined, the framework will implement the irest.IMessage interface. type ImplementDTOMessage struct{}","title":"ImplementDTOMessage"},{"location":"router/rest/rest/#allowmessage","text":"Used to transmit packet data and message name in string type. type AllowMessage struct { Package string Name string }","title":"AllowMessage"},{"location":"router/rest/rest/#allowmessagefullname","text":"Outputs the full name of the message. For example: main.Message. func (a *AllowMessage) FullName() string { return fmt.Sprintf(\"%s.%s\", a.Package, a.Name) }","title":"AllowMessage.FullName"},{"location":"router/rest/rest/#issafemessage","text":"Checks whether the message is safe. A message is safe if it is in allowed messages. func IsSafeMessage(message typeopr.IPtr, allowedMessages []AllowMessage) error { _type := reflect.TypeOf(message.Ptr()).Elem() if !typeopr.IsImplementInterface(message, (*irest.Message)(nil)) { return fmt.Errorf(\"%s message does not implement irest.IMessage interface\", _type) } // If the message type is passed through the irest.IMessage interface. if _type == reflect.TypeOf((*irest.Message)(nil)).Elem() { _type = reflect.TypeOf(reflect.ValueOf(message.Ptr()).Elem().Interface()) } pkgAndName := strings.Split(_type.String(), \".\") msg := AllowMessage{Package: pkgAndName[0], Name: pkgAndName[1]} if !fslice.SliceContains(allowedMessages, msg) { return fmt.Errorf(\"%s message is unsafe\", msg.FullName()) } return nil }","title":"IsSafeMessage"},{"location":"router/tmlengine/engine/","text":"TemplateEngine An object that renders data on an HTML page. Implements the TemplateEngine interface. The standard implementation uses the pongo2 template engine. TemplateEngine.New Implementation of the NewInstance interface. Creates a new instance of the TemplateEngine object with some predefined settings. func (e *TemplateEngine) New() (interface{}, error) { RegisterMultipleGlobalFilter(BuiltinFilters) return &TemplateEngine{context: make(map[string]interface{})}, nil } TemplateEngine.SetPath Sets the path to the HTML template. func (e *TemplateEngine) SetPath(path string) { e.path = path } TemplateEngine.Exec Does all the necessary processing for the template and shows the HTML code on the page. The CSRF token is also set in the context using the key namelib.ROUTER.COOKIE_CSRF_TOKEN . The token is taken from the cookie, and is usually set there using the TODO:add link SetCSRFToken function. func (e *TemplateEngine) Exec() error { debug.RequestLogginIfEnable(debug.P_TEMPLATE_ENGINE, \"exec template engine...\") debug.RequestLogginIfEnable(debug.P_TEMPLATE_ENGINE, \"processing html file\") err := e.processingFile() if err != nil { return err } debug.RequestLogginIfEnable(debug.P_TEMPLATE_ENGINE, \"set CSRF token\") err = e.setCsrfVariable(e.request) if err != nil { return err } debug.RequestLogginIfEnable(debug.P_TEMPLATE_ENGINE, \"execute template\") execute, err := e.templateFile.Execute(e.context) if err != nil { return err } debug.RequestLogginIfEnable(debug.P_TEMPLATE_ENGINE, \"write template\") _, err = e.writer.Write([]byte(execute)) if err != nil { return err } return nil } TemplateEngine.SetContext Sets the context for the template engine. This context can be retrieved in the template using the following syntax: {{ key }} . If the template engine is passed to pagerender and it is in turn passed to Manager , then the context will always be empty for each new HTTP request. func (e *TemplateEngine) SetContext(data map[string]interface{}) { fmap.MergeMapSync(&e.mu, &e.context, data) } TemplateEngine.GetContext Getting context. func (e *TemplateEngine) GetContext() map[string]interface{} { return e.context } TemplateEngine.SetResponseWriter Set http.ResponseWriter for internal use. func (e *TemplateEngine) SetResponseWriter(w http.ResponseWriter) { e.writer = w } TemplateEngine.SetRequest Set *http.Request for internal use. func (e *TemplateEngine) SetRequest(r *http.Request) { e.request = r } Filters Filters for the pongo2 template engine. Filter An object that represents a single instance of a filter. type Filter struct { Name string Fn pongo2.FilterFunction } RegisterGlobalFilter Registering global filters for templates. func RegisterGlobalFilter(name string, fn pongo2.FilterFunction) { pongo2.RegisterFilter(name, fn) } RegisterMultipleGlobalFilter Does the same thing as RegisterGlobalFilter , but accepts several filters at once as arguments. func RegisterMultipleGlobalFilter(filters []Filter) { for i := 0; i < len(filters); i++ { RegisterGlobalFilter(filters[i].Name, filters[i].Fn) } }","title":"Engine"},{"location":"router/tmlengine/engine/#templateengine","text":"An object that renders data on an HTML page. Implements the TemplateEngine interface. The standard implementation uses the pongo2 template engine.","title":"TemplateEngine"},{"location":"router/tmlengine/engine/#templateenginenew","text":"Implementation of the NewInstance interface. Creates a new instance of the TemplateEngine object with some predefined settings. func (e *TemplateEngine) New() (interface{}, error) { RegisterMultipleGlobalFilter(BuiltinFilters) return &TemplateEngine{context: make(map[string]interface{})}, nil }","title":"TemplateEngine.New"},{"location":"router/tmlengine/engine/#templateenginesetpath","text":"Sets the path to the HTML template. func (e *TemplateEngine) SetPath(path string) { e.path = path }","title":"TemplateEngine.SetPath"},{"location":"router/tmlengine/engine/#templateengineexec","text":"Does all the necessary processing for the template and shows the HTML code on the page. The CSRF token is also set in the context using the key namelib.ROUTER.COOKIE_CSRF_TOKEN . The token is taken from the cookie, and is usually set there using the TODO:add link SetCSRFToken function. func (e *TemplateEngine) Exec() error { debug.RequestLogginIfEnable(debug.P_TEMPLATE_ENGINE, \"exec template engine...\") debug.RequestLogginIfEnable(debug.P_TEMPLATE_ENGINE, \"processing html file\") err := e.processingFile() if err != nil { return err } debug.RequestLogginIfEnable(debug.P_TEMPLATE_ENGINE, \"set CSRF token\") err = e.setCsrfVariable(e.request) if err != nil { return err } debug.RequestLogginIfEnable(debug.P_TEMPLATE_ENGINE, \"execute template\") execute, err := e.templateFile.Execute(e.context) if err != nil { return err } debug.RequestLogginIfEnable(debug.P_TEMPLATE_ENGINE, \"write template\") _, err = e.writer.Write([]byte(execute)) if err != nil { return err } return nil }","title":"TemplateEngine.Exec"},{"location":"router/tmlengine/engine/#templateenginesetcontext","text":"Sets the context for the template engine. This context can be retrieved in the template using the following syntax: {{ key }} . If the template engine is passed to pagerender and it is in turn passed to Manager , then the context will always be empty for each new HTTP request. func (e *TemplateEngine) SetContext(data map[string]interface{}) { fmap.MergeMapSync(&e.mu, &e.context, data) }","title":"TemplateEngine.SetContext"},{"location":"router/tmlengine/engine/#templateenginegetcontext","text":"Getting context. func (e *TemplateEngine) GetContext() map[string]interface{} { return e.context }","title":"TemplateEngine.GetContext"},{"location":"router/tmlengine/engine/#templateenginesetresponsewriter","text":"Set http.ResponseWriter for internal use. func (e *TemplateEngine) SetResponseWriter(w http.ResponseWriter) { e.writer = w }","title":"TemplateEngine.SetResponseWriter"},{"location":"router/tmlengine/engine/#templateenginesetrequest","text":"Set *http.Request for internal use. func (e *TemplateEngine) SetRequest(r *http.Request) { e.request = r }","title":"TemplateEngine.SetRequest"},{"location":"router/tmlengine/engine/#filters","text":"Filters for the pongo2 template engine.","title":"Filters"},{"location":"router/tmlengine/engine/#filter","text":"An object that represents a single instance of a filter. type Filter struct { Name string Fn pongo2.FilterFunction }","title":"Filter"},{"location":"router/tmlengine/engine/#registerglobalfilter","text":"Registering global filters for templates. func RegisterGlobalFilter(name string, fn pongo2.FilterFunction) { pongo2.RegisterFilter(name, fn) }","title":"RegisterGlobalFilter"},{"location":"router/tmlengine/engine/#registermultipleglobalfilter","text":"Does the same thing as RegisterGlobalFilter , but accepts several filters at once as arguments. func RegisterMultipleGlobalFilter(filters []Filter) { for i := 0; i < len(filters); i++ { RegisterGlobalFilter(filters[i].Name, filters[i].Fn) } }","title":"RegisterMultipleGlobalFilter"},{"location":"router/tmlengine/pagerender/","text":"pagerender This module is designed for rendering HTML pages using a template engine. An object that implements the TemplateEngine interface is used for rendering. Render The object that controls the installed template engine. This object implements the Render and NewInstance interfaces. Example of use: ... newRender, err := tmlengine.NewRender() if err != nil { panic(err) } newManager := manager.NewManager( manager.NewOneTimeData(), newRender, database.NewDatabasePool(), ) ... newRouter.Register(router.MethodGET, \"/page\", func(w http.ResponseWriter, r *http.Request, manager interfaces.Manager) error { manager.Render().SetTemplatePath(\"index.html\") if err := manager.Render().RenderTemplate(w, r); err != nil { return err } return nil }) Render.SetContext Setting the context of the template engine. func (rn *Render) SetContext(data map[string]interface{}) { rn.TemplateEngine.SetContext(data) } Render.GetContext Getting context from the template engine. func (rn *Render) GetContext() map[string]interface{} { return rn.TemplateEngine.GetContext() } Render.SetTemplateEngine Set the template engine interface. Optional method if the template engine is already installed. func (rn *Render) SetTemplateEngine(engine interfaces.TemplateEngine) { rn.TemplateEngine = engine } Render.RenderTemplate Calls the methods of the TemplateEngine interface to configure and render the HTML template. func (rn *Render) RenderTemplate(w http.ResponseWriter, r *http.Request) error { if rn.templatePath == \"\" { return ErrTemplatePathNotSet{} } if !fpath.PathExist(rn.templatePath) { return ErrTemplatePathNotExist{Path: rn.templatePath} } rn.TemplateEngine.SetPath(rn.templatePath) rn.TemplateEngine.SetResponseWriter(w) rn.TemplateEngine.SetRequest(r) err := rn.TemplateEngine.Exec() if err != nil { return err } return nil } Render.SetTemplatePath Setting the path to the template that the templating engine renders. func (rn *Render) SetTemplatePath(templatePath string) { rn.templatePath = templatePath }","title":"Pagerender"},{"location":"router/tmlengine/pagerender/#pagerender","text":"This module is designed for rendering HTML pages using a template engine. An object that implements the TemplateEngine interface is used for rendering.","title":"pagerender"},{"location":"router/tmlengine/pagerender/#render","text":"The object that controls the installed template engine. This object implements the Render and NewInstance interfaces. Example of use: ... newRender, err := tmlengine.NewRender() if err != nil { panic(err) } newManager := manager.NewManager( manager.NewOneTimeData(), newRender, database.NewDatabasePool(), ) ... newRouter.Register(router.MethodGET, \"/page\", func(w http.ResponseWriter, r *http.Request, manager interfaces.Manager) error { manager.Render().SetTemplatePath(\"index.html\") if err := manager.Render().RenderTemplate(w, r); err != nil { return err } return nil })","title":"Render"},{"location":"router/tmlengine/pagerender/#rendersetcontext","text":"Setting the context of the template engine. func (rn *Render) SetContext(data map[string]interface{}) { rn.TemplateEngine.SetContext(data) }","title":"Render.SetContext"},{"location":"router/tmlengine/pagerender/#rendergetcontext","text":"Getting context from the template engine. func (rn *Render) GetContext() map[string]interface{} { return rn.TemplateEngine.GetContext() }","title":"Render.GetContext"},{"location":"router/tmlengine/pagerender/#rendersettemplateengine","text":"Set the template engine interface. Optional method if the template engine is already installed. func (rn *Render) SetTemplateEngine(engine interfaces.TemplateEngine) { rn.TemplateEngine = engine }","title":"Render.SetTemplateEngine"},{"location":"router/tmlengine/pagerender/#renderrendertemplate","text":"Calls the methods of the TemplateEngine interface to configure and render the HTML template. func (rn *Render) RenderTemplate(w http.ResponseWriter, r *http.Request) error { if rn.templatePath == \"\" { return ErrTemplatePathNotSet{} } if !fpath.PathExist(rn.templatePath) { return ErrTemplatePathNotExist{Path: rn.templatePath} } rn.TemplateEngine.SetPath(rn.templatePath) rn.TemplateEngine.SetResponseWriter(w) rn.TemplateEngine.SetRequest(r) err := rn.TemplateEngine.Exec() if err != nil { return err } return nil }","title":"Render.RenderTemplate"},{"location":"router/tmlengine/pagerender/#rendersettemplatepath","text":"Setting the path to the template that the templating engine renders. func (rn *Render) SetTemplatePath(templatePath string) { rn.templatePath = templatePath }","title":"Render.SetTemplatePath"},{"location":"router/tmlengine/tmlengine/","text":"package tmlengine This package contains tools for displaying data on an HTML page and working with it. Here are the modules included in it: engine \u2014 template engine for page rendering. pagerender \u2014 template management and start page rendering.","title":"Tmlengine"},{"location":"router/tmlengine/tmlengine/#package-tmlengine","text":"This package contains tools for displaying data on an HTML page and working with it. Here are the modules included in it: engine \u2014 template engine for page rendering. pagerender \u2014 template management and start page rendering.","title":"package tmlengine"},{"location":"secure/csrf_token/","text":"CSRF token The package specializes in working with CSRF tokens. ValidateCookieCsrfToken Checks the validity of the csrf token. If no errors are detected, the token is valid. It is desirable to use this method only after form.Parse method. func ValidateCookieCsrfToken(r *http.Request, token string) error { if token == \"\" { return ErrCsrfTokenNotFound{} } cookie, err := r.Cookie(namelib.ROUTER.COOKIE_CSRF_TOKEN) if err != nil { return err } if cookie.Value != token { return ErrCsrfTokenDoesNotMatch{} } return nil } ValidateHeaderCSRFToken Validates the CSRF token based on its value in the header. For proper operation, the token must be set in cookies before verification. func ValidateHeaderCSRFToken(r *http.Request, tokenName string) error { csrfToken := r.Header.Get(tokenName) if csrfToken == \"\" { return ErrCsrfTokenNotFound{} } return ValidateCookieCsrfToken(r, csrfToken) } GenerateCsrfToken Generates a CSRF token. func GenerateCsrfToken() (string, error) { tokenBytes := make([]byte, 32) _, err := rand.Read(tokenBytes) if err != nil { return \"\", err } csrfToken := base64.StdEncoding.EncodeToString(tokenBytes) return csrfToken, nil } SetCSRFToken Sets the CSRF token in the cookie. Also, if Render is previously installed in the manager , sets the template context input with the token by the key namelib.ROUTER.COOKIE_CSRF_TOKEN . func SetCSRFToken(maxAge int, httpOnly bool, w http.ResponseWriter, r *http.Request, manager interfaces.Manager) error { csrfCookie, err := r.Cookie(namelib.ROUTER.COOKIE_CSRF_TOKEN) if err != nil || csrfCookie.Value == \"\" { csrfToken, err := GenerateCsrfToken() if err != nil { return err } cookie := &http.Cookie{ Name: namelib.ROUTER.COOKIE_CSRF_TOKEN, Value: csrfToken, MaxAge: maxAge, HttpOnly: httpOnly, Secure: true, SameSite: http.SameSiteStrictMode, Path: \"/\", } http.SetCookie(w, cookie) csrfHTMLString := fmt.Sprintf(\"<input name=\\\"%s\\\" type=\\\"hidden\\\" value=\\\"%s\\\">\", namelib.ROUTER.COOKIE_CSRF_TOKEN, csrfToken) if manager.Render() != nil { manager.Render().SetContext(map[string]interface{}{namelib.ROUTER.COOKIE_CSRF_TOKEN: csrfHTMLString}) } manager.OneTimeData().SetUserContext(namelib.ROUTER.COOKIE_CSRF_TOKEN, csrfHTMLString) } return nil }","title":"CSRF token"},{"location":"secure/csrf_token/#csrf-token","text":"The package specializes in working with CSRF tokens.","title":"CSRF token"},{"location":"secure/csrf_token/#validatecookiecsrftoken","text":"Checks the validity of the csrf token. If no errors are detected, the token is valid. It is desirable to use this method only after form.Parse method. func ValidateCookieCsrfToken(r *http.Request, token string) error { if token == \"\" { return ErrCsrfTokenNotFound{} } cookie, err := r.Cookie(namelib.ROUTER.COOKIE_CSRF_TOKEN) if err != nil { return err } if cookie.Value != token { return ErrCsrfTokenDoesNotMatch{} } return nil }","title":"ValidateCookieCsrfToken"},{"location":"secure/csrf_token/#validateheadercsrftoken","text":"Validates the CSRF token based on its value in the header. For proper operation, the token must be set in cookies before verification. func ValidateHeaderCSRFToken(r *http.Request, tokenName string) error { csrfToken := r.Header.Get(tokenName) if csrfToken == \"\" { return ErrCsrfTokenNotFound{} } return ValidateCookieCsrfToken(r, csrfToken) }","title":"ValidateHeaderCSRFToken"},{"location":"secure/csrf_token/#generatecsrftoken","text":"Generates a CSRF token. func GenerateCsrfToken() (string, error) { tokenBytes := make([]byte, 32) _, err := rand.Read(tokenBytes) if err != nil { return \"\", err } csrfToken := base64.StdEncoding.EncodeToString(tokenBytes) return csrfToken, nil }","title":"GenerateCsrfToken"},{"location":"secure/csrf_token/#setcsrftoken","text":"Sets the CSRF token in the cookie. Also, if Render is previously installed in the manager , sets the template context input with the token by the key namelib.ROUTER.COOKIE_CSRF_TOKEN . func SetCSRFToken(maxAge int, httpOnly bool, w http.ResponseWriter, r *http.Request, manager interfaces.Manager) error { csrfCookie, err := r.Cookie(namelib.ROUTER.COOKIE_CSRF_TOKEN) if err != nil || csrfCookie.Value == \"\" { csrfToken, err := GenerateCsrfToken() if err != nil { return err } cookie := &http.Cookie{ Name: namelib.ROUTER.COOKIE_CSRF_TOKEN, Value: csrfToken, MaxAge: maxAge, HttpOnly: httpOnly, Secure: true, SameSite: http.SameSiteStrictMode, Path: \"/\", } http.SetCookie(w, cookie) csrfHTMLString := fmt.Sprintf(\"<input name=\\\"%s\\\" type=\\\"hidden\\\" value=\\\"%s\\\">\", namelib.ROUTER.COOKIE_CSRF_TOKEN, csrfToken) if manager.Render() != nil { manager.Render().SetContext(map[string]interface{}{namelib.ROUTER.COOKIE_CSRF_TOKEN: csrfHTMLString}) } manager.OneTimeData().SetUserContext(namelib.ROUTER.COOKIE_CSRF_TOKEN, csrfHTMLString) } return nil }","title":"SetCSRFToken"},{"location":"secure/header/","text":"Header Ready-made modules for protection via Header. SetCSP Setting CSP. CSP (Content Security Policy) is a security mechanism implemented through HTTP headers or meta tags that helps prevent XSS (Cross-Site Scripting) attacks, injection, and other vulnerabilities associated with the introduction of malicious content. func SetCSP(w http.ResponseWriter, directives map[string][]string) error { var directivesString bytes.Buffer for name, value := range directives { _, err := directivesString.WriteString(name + \" \") if err != nil { return err } for i := 0; i < len(value); i++ { if i == len(value)-1 { _, err := directivesString.WriteString(value[i] + \"; \") if err != nil { return err } } else { _, err := directivesString.WriteString(value[i] + \" \") if err != nil { return err } } } } w.Header().Set(\"Content-Security-Policy\", directivesString.String()) return nil } SetAntiClickjacking Setting AntiClickjacking. Anti-clickjacking refers to protective measures that prevent your website from being embedded in an <iframe> so that attackers cannot use clickjacking attacks. func SetAntiClickjacking(w http.ResponseWriter, acOption string) { w.Header().Set(\"X-Frame-Options\", acOption) }","title":"Header"},{"location":"secure/header/#header","text":"Ready-made modules for protection via Header.","title":"Header"},{"location":"secure/header/#setcsp","text":"Setting CSP. CSP (Content Security Policy) is a security mechanism implemented through HTTP headers or meta tags that helps prevent XSS (Cross-Site Scripting) attacks, injection, and other vulnerabilities associated with the introduction of malicious content. func SetCSP(w http.ResponseWriter, directives map[string][]string) error { var directivesString bytes.Buffer for name, value := range directives { _, err := directivesString.WriteString(name + \" \") if err != nil { return err } for i := 0; i < len(value); i++ { if i == len(value)-1 { _, err := directivesString.WriteString(value[i] + \"; \") if err != nil { return err } } else { _, err := directivesString.WriteString(value[i] + \" \") if err != nil { return err } } } } w.Header().Set(\"Content-Security-Policy\", directivesString.String()) return nil }","title":"SetCSP"},{"location":"secure/header/#setanticlickjacking","text":"Setting AntiClickjacking. Anti-clickjacking refers to protective measures that prevent your website from being embedded in an <iframe> so that attackers cannot use clickjacking attacks. func SetAntiClickjacking(w http.ResponseWriter, acOption string) { w.Header().Set(\"X-Frame-Options\", acOption) }","title":"SetAntiClickjacking"},{"location":"secure/hmac/","text":"HMAC Implementation and working with the HMAC algorithm. GenerateHMAC Generates an HMAC signature using the SHA-256 algorithm and a key. func GenerateHMAC(hashKey []byte, data []byte) ([]byte, error) { newHMAC := hmac.New(sha256.New, hashKey) _, err := newHMAC.Write(data) if err != nil { return nil, err } return newHMAC.Sum(nil), nil } VerifyHMAC Compares the received signature with the correct one. data - expected content. func VerifyHMAC(hashKey []byte, data []byte, hmacCode []byte) (bool, error) { // A valid signature has been generated and is expected. expectedHMAC, err := GenerateHMAC(hashKey, data) if err != nil { return false, err } return hmac.Equal(expectedHMAC, hmacCode), nil } Encrypt The function is designed to encrypt data using the AES encryption algorithm in GCM mode (Galois/Counter Mode). func Encrypt(blockKey []byte, data []byte) (string, error) { cipherBlock, err := aes.NewCipher(blockKey) if err != nil { return \"\", err } gcm, err := cipher.NewGCM(cipherBlock) if err != nil { return \"\", err } nonce := make([]byte, gcm.NonceSize()) if _, err := io.ReadFull(rand.Reader, nonce); err != nil { return \"\", err } cipherText := gcm.Seal(nonce, nonce, data, nil) return base64.StdEncoding.EncodeToString(cipherText), nil } Decrypt Function is designed to decrypt data that was encrypted using the Encrypt function. It creates AES and GCM using the same key and uses them to decrypt the data. func Decrypt(blockKey []byte, enc string) ([]byte, error) { data, err := base64.StdEncoding.DecodeString(enc) if err != nil { return nil, err } cipherBlock, err := aes.NewCipher(blockKey) if err != nil { return nil, err } gcm, err := cipher.NewGCM(cipherBlock) if err != nil { return nil, err } nonceSize := gcm.NonceSize() nonce, ciphertext := data[:nonceSize], data[nonceSize:] return gcm.Open(nil, nonce, ciphertext, nil) } CreateSecureData Creates encrypted data using hmac and the Encrypt function. func CreateSecureData(hashKey []byte, blockKey []byte, writeData interface{}) (string, error) { if reflect.TypeOf(writeData).Kind() != reflect.Pointer { return \"\", errors.New(\"the writeData argument must be a pointer\") } data, err := json.Marshal(writeData) if err != nil { return \"\", err } genereatedHMAC, err := GenerateHMAC(hashKey, data) if err != nil { return \"\", err } data = append(data, genereatedHMAC...) return Encrypt(blockKey, data) } ReadSecureData Reads encrypted data created using CreateSecureData . All keys must match. func ReadSecureData(hashKey []byte, blockKey []byte, secureData string, readData interface{}) error { if reflect.TypeOf(readData).Kind() != reflect.Pointer { return errors.New(\"the writeData argument must be a pointer\") } data, err := Decrypt(blockKey, secureData) if err != nil { return err } sig := data[len(data)-sha256.Size:] data1 := data[:len(data)-sha256.Size] isValidHMAC, err := VerifyHMAC(hashKey, data1, sig) if err != nil { return err } if !isValidHMAC { return ErrInvalidHMAC{} } if err := json.Unmarshal(data1, readData); err != nil { return err } return nil }","title":"HMAC"},{"location":"secure/hmac/#hmac","text":"Implementation and working with the HMAC algorithm.","title":"HMAC"},{"location":"secure/hmac/#generatehmac","text":"Generates an HMAC signature using the SHA-256 algorithm and a key. func GenerateHMAC(hashKey []byte, data []byte) ([]byte, error) { newHMAC := hmac.New(sha256.New, hashKey) _, err := newHMAC.Write(data) if err != nil { return nil, err } return newHMAC.Sum(nil), nil }","title":"GenerateHMAC"},{"location":"secure/hmac/#verifyhmac","text":"Compares the received signature with the correct one. data - expected content. func VerifyHMAC(hashKey []byte, data []byte, hmacCode []byte) (bool, error) { // A valid signature has been generated and is expected. expectedHMAC, err := GenerateHMAC(hashKey, data) if err != nil { return false, err } return hmac.Equal(expectedHMAC, hmacCode), nil }","title":"VerifyHMAC"},{"location":"secure/hmac/#encrypt","text":"The function is designed to encrypt data using the AES encryption algorithm in GCM mode (Galois/Counter Mode). func Encrypt(blockKey []byte, data []byte) (string, error) { cipherBlock, err := aes.NewCipher(blockKey) if err != nil { return \"\", err } gcm, err := cipher.NewGCM(cipherBlock) if err != nil { return \"\", err } nonce := make([]byte, gcm.NonceSize()) if _, err := io.ReadFull(rand.Reader, nonce); err != nil { return \"\", err } cipherText := gcm.Seal(nonce, nonce, data, nil) return base64.StdEncoding.EncodeToString(cipherText), nil }","title":"Encrypt"},{"location":"secure/hmac/#decrypt","text":"Function is designed to decrypt data that was encrypted using the Encrypt function. It creates AES and GCM using the same key and uses them to decrypt the data. func Decrypt(blockKey []byte, enc string) ([]byte, error) { data, err := base64.StdEncoding.DecodeString(enc) if err != nil { return nil, err } cipherBlock, err := aes.NewCipher(blockKey) if err != nil { return nil, err } gcm, err := cipher.NewGCM(cipherBlock) if err != nil { return nil, err } nonceSize := gcm.NonceSize() nonce, ciphertext := data[:nonceSize], data[nonceSize:] return gcm.Open(nil, nonce, ciphertext, nil) }","title":"Decrypt"},{"location":"secure/hmac/#createsecuredata","text":"Creates encrypted data using hmac and the Encrypt function. func CreateSecureData(hashKey []byte, blockKey []byte, writeData interface{}) (string, error) { if reflect.TypeOf(writeData).Kind() != reflect.Pointer { return \"\", errors.New(\"the writeData argument must be a pointer\") } data, err := json.Marshal(writeData) if err != nil { return \"\", err } genereatedHMAC, err := GenerateHMAC(hashKey, data) if err != nil { return \"\", err } data = append(data, genereatedHMAC...) return Encrypt(blockKey, data) }","title":"CreateSecureData"},{"location":"secure/hmac/#readsecuredata","text":"Reads encrypted data created using CreateSecureData . All keys must match. func ReadSecureData(hashKey []byte, blockKey []byte, secureData string, readData interface{}) error { if reflect.TypeOf(readData).Kind() != reflect.Pointer { return errors.New(\"the writeData argument must be a pointer\") } data, err := Decrypt(blockKey, secureData) if err != nil { return err } sig := data[len(data)-sha256.Size:] data1 := data[:len(data)-sha256.Size] isValidHMAC, err := VerifyHMAC(hashKey, data1, sig) if err != nil { return err } if !isValidHMAC { return ErrInvalidHMAC{} } if err := json.Unmarshal(data1, readData); err != nil { return err } return nil }","title":"ReadSecureData"},{"location":"secure/jwt/","text":"JWT Working with JWT tokens. NewHmacJwtWithClaims Creating a JWT token. The library github.com/golang-jwt/jwt/v5 is used for creation. func NewHmacJwtWithClaims(claims jwt.Claims, manager interfaces.Manager) (string, error) { token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims) tokenString, err := token.SignedString([]byte(manager.Key().Get32BytesKey().HashKey())) if err != nil { return \"\", err } return tokenString, nil }","title":"JWT"},{"location":"secure/jwt/#jwt","text":"Working with JWT tokens.","title":"JWT"},{"location":"secure/jwt/#newhmacjwtwithclaims","text":"Creating a JWT token. The library github.com/golang-jwt/jwt/v5 is used for creation. func NewHmacJwtWithClaims(claims jwt.Claims, manager interfaces.Manager) (string, error) { token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims) tokenString, err := token.SignedString([]byte(manager.Key().Get32BytesKey().HashKey())) if err != nil { return \"\", err } return tokenString, nil }","title":"NewHmacJwtWithClaims"},{"location":"secure/key/","text":"Key Key structure that generates and stores three types of keys: hashKey \u2014 a key that is used for HMAC and can be dynamic. blockKey \u2014 a key that is used for encoding and can be dynamic. staticKey \u2014 a key that cannot change. The old keys haskKey and blockKey are also stored here. Key.GenerateBytesKeys Generates keys. hashKey and blockKey will be updated. staticKey will only be generated once, cannot be regenerated. func (k *Key) GenerateBytesKeys(length int) { k.oldHashKey = k.hashKey k.oldBlockKey = k.blockKey k.hashKey = string(k.generateKeys(length)) k.blockKey = string(k.generateKeys(length)) if k.staticKey == \"\" { k.staticKey = string(k.generateKeys(length)) } k.date = time.Now() } Key.Generate32BytesKeys Generates keys with a length of 32 bytes. func (k *Key) Generate32BytesKeys() { k.GenerateBytesKeys(32) } Key.HashKey Getting HashKey. func (k *Key) HashKey() string { return k.hashKey } Key.OldHashKey Getting the old OldHashKey. func (k *Key) OldHashKey() string { return k.oldHashKey } Key.BlockKey Getting BlockKey. func (k *Key) BlockKey() string { return k.blockKey } Key.OldBlockKey Getting the old OldBlockKey. func (k *Key) OldBlockKey() string { return k.oldBlockKey } Key.StaticKey Getting StaticKey. func (k *Key) StaticKey() string { return k.staticKey } Key.Date Getting the date of the last key update. func (k *Key) Date() time.Time { return k.date }","title":"Key"},{"location":"secure/key/#key","text":"Key structure that generates and stores three types of keys: hashKey \u2014 a key that is used for HMAC and can be dynamic. blockKey \u2014 a key that is used for encoding and can be dynamic. staticKey \u2014 a key that cannot change. The old keys haskKey and blockKey are also stored here.","title":"Key"},{"location":"secure/key/#keygeneratebyteskeys","text":"Generates keys. hashKey and blockKey will be updated. staticKey will only be generated once, cannot be regenerated. func (k *Key) GenerateBytesKeys(length int) { k.oldHashKey = k.hashKey k.oldBlockKey = k.blockKey k.hashKey = string(k.generateKeys(length)) k.blockKey = string(k.generateKeys(length)) if k.staticKey == \"\" { k.staticKey = string(k.generateKeys(length)) } k.date = time.Now() }","title":"Key.GenerateBytesKeys"},{"location":"secure/key/#keygenerate32byteskeys","text":"Generates keys with a length of 32 bytes. func (k *Key) Generate32BytesKeys() { k.GenerateBytesKeys(32) }","title":"Key.Generate32BytesKeys"},{"location":"secure/key/#keyhashkey","text":"Getting HashKey. func (k *Key) HashKey() string { return k.hashKey }","title":"Key.HashKey"},{"location":"secure/key/#keyoldhashkey","text":"Getting the old OldHashKey. func (k *Key) OldHashKey() string { return k.oldHashKey }","title":"Key.OldHashKey"},{"location":"secure/key/#keyblockkey","text":"Getting BlockKey. func (k *Key) BlockKey() string { return k.blockKey }","title":"Key.BlockKey"},{"location":"secure/key/#keyoldblockkey","text":"Getting the old OldBlockKey. func (k *Key) OldBlockKey() string { return k.oldBlockKey }","title":"Key.OldBlockKey"},{"location":"secure/key/#keystatickey","text":"Getting StaticKey. func (k *Key) StaticKey() string { return k.staticKey }","title":"Key.StaticKey"},{"location":"secure/key/#keydate","text":"Getting the date of the last key update. func (k *Key) Date() time.Time { return k.date }","title":"Key.Date"},{"location":"server/server/","text":"package server The package is responsible for the operation of the framework server. Server An object that stores server data and launches the server. NewServer Creating a new server instance. The rcors argument is responsible for launching CORS together with the server . The argument can be nil. CORS is implemented using https://github.com/rs/cors . func NewServer(addr string, router *router.Router, rcors *cors.Options) *Server { s := &Server{router: router, addr: addr} var handler http.Handler = router if rcors != nil { handler = cors.New(*rcors).Handler(handler) } s.serv = &http.Server{ Addr: s.addr, Handler: handler, } return s } Server.Start Starts listening for connections on the selected address. func (s *Server) Start() error { fmt.Printf(\"Server start on %s\", s.addr) err := s.serv.ListenAndServe() if err != nil { return err } return nil } Server.GetServ Returns an *http.Server object. func (s *Server) GetServ() *http.Server { return s.serv } Server.Stop Stopping server listening. func (s *Server) Stop() error { if err := s.serv.Close(); err != nil { return err } println(\"Server stopped.\") return nil } MicServer Server implementation object for microservices. MicServer.Start Starts listening for connections on the selected address. func (mc *MicServer) Start() error { lis, err := net.Listen(mc.Network, mc.Address) if err != nil { return err } log.Printf(\"Mic server start on %v\", lis.Addr()) if err := mc.GrpcServer.Serve(lis); err != nil { return err } return nil } FoozyAndMic Launching two servers simultaneously: Server MicServer func FoozyAndMic(fserver *Server, micServer *MicServer, onError func(err error)) { var wg sync.WaitGroup wg.Add(1) go func() { err := fserver.Start() if err != nil { onError(err) } }() wg.Add(1) go func() { err := micServer.Start() if err != nil { onError(err) } }() wg.Wait() } WaitStartServer Waits for the server to start at the selected address for the specified amount of time. If the connection did not appear during this time, it returns an error. IMPORTANT: Either the server or this function must be run in a goroutine, otherwise it may not work. func WaitStartServer(addr string, waitTimeSec int) error { var outErr error for i := 0; i < waitTimeSec; i++ { time.Sleep(1 * time.Second) conn, err := net.DialTimeout(\"tcp\", addr, 1*time.Second) if conn != nil { conn.Close() } if err != nil { outErr = ErrResponseTimedOut{addr} } else { outErr = nil break } } return outErr }","title":"Server"},{"location":"server/server/#package-server","text":"The package is responsible for the operation of the framework server.","title":"package server"},{"location":"server/server/#server","text":"An object that stores server data and launches the server.","title":"Server"},{"location":"server/server/#newserver","text":"Creating a new server instance. The rcors argument is responsible for launching CORS together with the server . The argument can be nil. CORS is implemented using https://github.com/rs/cors . func NewServer(addr string, router *router.Router, rcors *cors.Options) *Server { s := &Server{router: router, addr: addr} var handler http.Handler = router if rcors != nil { handler = cors.New(*rcors).Handler(handler) } s.serv = &http.Server{ Addr: s.addr, Handler: handler, } return s }","title":"NewServer"},{"location":"server/server/#serverstart","text":"Starts listening for connections on the selected address. func (s *Server) Start() error { fmt.Printf(\"Server start on %s\", s.addr) err := s.serv.ListenAndServe() if err != nil { return err } return nil }","title":"Server.Start"},{"location":"server/server/#servergetserv","text":"Returns an *http.Server object. func (s *Server) GetServ() *http.Server { return s.serv }","title":"Server.GetServ"},{"location":"server/server/#serverstop","text":"Stopping server listening. func (s *Server) Stop() error { if err := s.serv.Close(); err != nil { return err } println(\"Server stopped.\") return nil }","title":"Server.Stop"},{"location":"server/server/#micserver","text":"Server implementation object for microservices.","title":"MicServer"},{"location":"server/server/#micserverstart","text":"Starts listening for connections on the selected address. func (mc *MicServer) Start() error { lis, err := net.Listen(mc.Network, mc.Address) if err != nil { return err } log.Printf(\"Mic server start on %v\", lis.Addr()) if err := mc.GrpcServer.Serve(lis); err != nil { return err } return nil }","title":"MicServer.Start"},{"location":"server/server/#foozyandmic","text":"Launching two servers simultaneously: Server MicServer func FoozyAndMic(fserver *Server, micServer *MicServer, onError func(err error)) { var wg sync.WaitGroup wg.Add(1) go func() { err := fserver.Start() if err != nil { onError(err) } }() wg.Add(1) go func() { err := micServer.Start() if err != nil { onError(err) } }() wg.Wait() }","title":"FoozyAndMic"},{"location":"server/server/#waitstartserver","text":"Waits for the server to start at the selected address for the specified amount of time. If the connection did not appear during this time, it returns an error. IMPORTANT: Either the server or this function must be run in a goroutine, otherwise it may not work. func WaitStartServer(addr string, waitTimeSec int) error { var outErr error for i := 0; i < waitTimeSec; i++ { time.Sleep(1 * time.Second) conn, err := net.DialTimeout(\"tcp\", addr, 1*time.Second) if conn != nil { conn.Close() } if err != nil { outErr = ErrResponseTimedOut{addr} } else { outErr = nil break } } return outErr }","title":"WaitStartServer"},{"location":"server/globalflow/globalflow/","text":"package globalflow GlobalFlow Creates a flow that runs separately from the server. It is used for constant calculations, because it constantly runs tasks. There are two types of tasks: tasks - are executed asynchronously, but wait for all tasks in the iteration to be completed. notWaitTasks - are executed asynchronously, but do not wait for all tasks in the iteration to be completed. That is, task1 may still be executed for the first time, and task2 may already be executed 4 times. It is impossible to launch two instances of the same task, this means that task1 will only start again when it has completed its execution. IMPORTANT: it is recommended to set a delay of at least 1000 milliseconds (1 second). GlobalFlow.AddTask Adding tasks that complete execution synchronously. func (gf *GlobalFlow) AddTask(task Task) { gf.tasks = append(gf.tasks, task) } GlobalFlow.AddNotWaitTask Adds tasks that do not wait for synchronous completion. func (gf *GlobalFlow) AddNotWaitTask(task Task) { gf.noWaitTasks.Store(gf.noWaitTasksIndex, task) gf.working.Store(gf.noWaitTasksIndex, false) gf.noWaitTasksIndex++ } GlobalFlow.Run Starts the execution of two types of tasks in two separate goroutines. func (gf *GlobalFlow) Run(manager interfaces.Manager) { if !typeopr.IsPointer(manager) { panic(\"The managerConfig must be passed by pointer.\") } // Wait tasks. if len(gf.tasks) > 0 { var wg sync.WaitGroup go func() { for { for i := 0; i < len(gf.tasks); i++ { wg.Add(1) go func(i int) { defer wg.Done() gf.tasks[i](manager) }(i) } wg.Wait() time.Sleep(time.Duration(gf.delayMilliseconds) * time.Millisecond) } }() } // No wait tasks. if gf.noWaitTasksIndex > 0 { go func() { // Description of the algorithm: // 1. gf.working[i] is false before starting goroutines. // 2. gf.working[i] is true when the goroutine has started // 3. gf.working[i] is false when the goroutine has completed // 4. if gf.working[i] is true, the task is running and you should skip running this task. for { for i := 0; i < gf.noWaitTasksIndex; i++ { wrk, _ := gf.working.Load(i) if !wrk.(bool) { go func(i int) { defer func() { gf.working.Store(i, false) }() gf.working.Store(i, true) callTask, _ := gf.noWaitTasks.Load(i) callTask.(Task)(manager) }(i) } } time.Sleep(time.Duration(gf.delayMilliseconds) * time.Millisecond) } }() } }","title":"Globalflow"},{"location":"server/globalflow/globalflow/#package-globalflow","text":"","title":"package globalflow"},{"location":"server/globalflow/globalflow/#globalflow","text":"Creates a flow that runs separately from the server. It is used for constant calculations, because it constantly runs tasks. There are two types of tasks: tasks - are executed asynchronously, but wait for all tasks in the iteration to be completed. notWaitTasks - are executed asynchronously, but do not wait for all tasks in the iteration to be completed. That is, task1 may still be executed for the first time, and task2 may already be executed 4 times. It is impossible to launch two instances of the same task, this means that task1 will only start again when it has completed its execution. IMPORTANT: it is recommended to set a delay of at least 1000 milliseconds (1 second).","title":"GlobalFlow"},{"location":"server/globalflow/globalflow/#globalflowaddtask","text":"Adding tasks that complete execution synchronously. func (gf *GlobalFlow) AddTask(task Task) { gf.tasks = append(gf.tasks, task) }","title":"GlobalFlow.AddTask"},{"location":"server/globalflow/globalflow/#globalflowaddnotwaittask","text":"Adds tasks that do not wait for synchronous completion. func (gf *GlobalFlow) AddNotWaitTask(task Task) { gf.noWaitTasks.Store(gf.noWaitTasksIndex, task) gf.working.Store(gf.noWaitTasksIndex, false) gf.noWaitTasksIndex++ }","title":"GlobalFlow.AddNotWaitTask"},{"location":"server/globalflow/globalflow/#globalflowrun","text":"Starts the execution of two types of tasks in two separate goroutines. func (gf *GlobalFlow) Run(manager interfaces.Manager) { if !typeopr.IsPointer(manager) { panic(\"The managerConfig must be passed by pointer.\") } // Wait tasks. if len(gf.tasks) > 0 { var wg sync.WaitGroup go func() { for { for i := 0; i < len(gf.tasks); i++ { wg.Add(1) go func(i int) { defer wg.Done() gf.tasks[i](manager) }(i) } wg.Wait() time.Sleep(time.Duration(gf.delayMilliseconds) * time.Millisecond) } }() } // No wait tasks. if gf.noWaitTasksIndex > 0 { go func() { // Description of the algorithm: // 1. gf.working[i] is false before starting goroutines. // 2. gf.working[i] is true when the goroutine has started // 3. gf.working[i] is false when the goroutine has completed // 4. if gf.working[i] is true, the task is running and you should skip running this task. for { for i := 0; i < gf.noWaitTasksIndex; i++ { wrk, _ := gf.working.Load(i) if !wrk.(bool) { go func(i int) { defer func() { gf.working.Store(i, false) }() gf.working.Store(i, true) callTask, _ := gf.noWaitTasks.Load(i) callTask.(Task)(manager) }(i) } } time.Sleep(time.Duration(gf.delayMilliseconds) * time.Millisecond) } }() } }","title":"GlobalFlow.Run"},{"location":"server/livereload/livereload/","text":"livereload This package implements a system for reloading after saving a file. It does not interact directly with the framework and is an optional component, but it makes development much easier. Example of use: package main import ( initcnf \"github.com/uwine4850/foozy/mycmd/init_cnf\" \"github.com/uwine4850/foozy/pkg/server/livereload\" ) func main() { initcnf.InitCnf() wrt := livereload.NewWiretap() wrt.SetDirs([]string{\"cnf\"}) reload := livereload.NewReloader(\"main.go\", wrt) if err := reload.Start(); err != nil { panic(err) } } More details about the package components: wiretap reload","title":"Livereload"},{"location":"server/livereload/livereload/#livereload","text":"This package implements a system for reloading after saving a file. It does not interact directly with the framework and is an optional component, but it makes development much easier. Example of use: package main import ( initcnf \"github.com/uwine4850/foozy/mycmd/init_cnf\" \"github.com/uwine4850/foozy/pkg/server/livereload\" ) func main() { initcnf.InitCnf() wrt := livereload.NewWiretap() wrt.SetDirs([]string{\"cnf\"}) reload := livereload.NewReloader(\"main.go\", wrt) if err := reload.Start(); err != nil { panic(err) } } More details about the package components: wiretap reload","title":"livereload"},{"location":"server/livereload/reload/","text":"Reloader An object that is responsible for restarting the application. It builds the application into a binary file and launches it; after the trigger, it repeats this process. It uses Wiretap for its work. Reloader.Start Starts listening for files to change and restarts the server. func (r *Reloader) Start() error { r.wiretap.OnStart(func() { r.onStart() }) r.wiretap.OnTrigger(func(filePath string) { r.onTrigger() }) if err := r.wiretap.Start(); err != nil { return err } return nil } Reloader.onStart Actions that are performed at the start. Here the application binary file is built, and then this file is running. func (r *Reloader) onStart() { cmd := exec.Command(\"go\", \"build\", \"-o\", \"myapp\", r.serverEntryPointPath) var stderrBuf bytes.Buffer cmd.Stderr = io.MultiWriter(&stderrBuf, os.Stderr) if err := cmd.Run(); err != nil { fmt.Println(\"Error:\", stderrBuf.String()) } r.serverProcess = exec.Command(\"./myapp\") r.serverProcess.Stdout = os.Stdout r.serverProcess.Stderr = os.Stderr if err := r.serverProcess.Start(); err != nil { panic(err) } } Reloader.onTrigger Action during a file reload. The server stops and then the onStart method is called, which starts the rebuilt application again. func (r *Reloader) onTrigger() { if err := r.serverProcess.Process.Kill(); err != nil { fmt.Println(err) } if _, err := r.serverProcess.Process.Wait(); err != nil { fmt.Println(\"err\") } r.onStart() }","title":"Reload"},{"location":"server/livereload/reload/#reloader","text":"An object that is responsible for restarting the application. It builds the application into a binary file and launches it; after the trigger, it repeats this process. It uses Wiretap for its work.","title":"Reloader"},{"location":"server/livereload/reload/#reloaderstart","text":"Starts listening for files to change and restarts the server. func (r *Reloader) Start() error { r.wiretap.OnStart(func() { r.onStart() }) r.wiretap.OnTrigger(func(filePath string) { r.onTrigger() }) if err := r.wiretap.Start(); err != nil { return err } return nil }","title":"Reloader.Start"},{"location":"server/livereload/reload/#reloaderonstart","text":"Actions that are performed at the start. Here the application binary file is built, and then this file is running. func (r *Reloader) onStart() { cmd := exec.Command(\"go\", \"build\", \"-o\", \"myapp\", r.serverEntryPointPath) var stderrBuf bytes.Buffer cmd.Stderr = io.MultiWriter(&stderrBuf, os.Stderr) if err := cmd.Run(); err != nil { fmt.Println(\"Error:\", stderrBuf.String()) } r.serverProcess = exec.Command(\"./myapp\") r.serverProcess.Stdout = os.Stdout r.serverProcess.Stderr = os.Stderr if err := r.serverProcess.Start(); err != nil { panic(err) } }","title":"Reloader.onStart"},{"location":"server/livereload/reload/#reloaderontrigger","text":"Action during a file reload. The server stops and then the onStart method is called, which starts the rebuilt application again. func (r *Reloader) onTrigger() { if err := r.serverProcess.Process.Kill(); err != nil { fmt.Println(err) } if _, err := r.serverProcess.Process.Wait(); err != nil { fmt.Println(\"err\") } r.onStart() }","title":"Reloader.onTrigger"},{"location":"server/livereload/wiretap/","text":"wiretap Starts listening to selected files using the InotifyEvent system event. When at least one file save is detected, it calls the trigger function. SetObserverEventDelay Pause time between the execution of an event for one observation. This delay applies to each observation separately. func SetObserverEventDelay(delay int) { observedEventDelay = time.Duration(delay) * time.Millisecond } ObservedElement One element to track, file or directory (all files in it are tracked). ObservedElement.Ready Shows whether the delay between invents has passed and whether the file is ready before the re-invent. func (of *ObservedElement) Ready() bool { return time.Since(of.LastEventTime) > observedEventDelay } Wiretap An object that monitors files and triggers an event when one of them is saved. The global algorithm works as follows: The user sets up the elements to be monitored. The elements to be monitored are processed and start listening using syscall.SYS_INOTIFY_ADD_WATCH . A cycle is started that waits for InotifyEvent and processes it. When InotifyEvent occurs, the trigger is activated. Wiretap.OnStart Starts every time during the start of the wiretapping. The method is usually needed for preliminary initialization before monitoring begins. func (w *Wiretap) OnStart(fn func()) { w.onStartFn = fn } Wiretap.OnTrigger A function that will be executed each time the trigger is executed. func (w *Wiretap) OnTrigger(fn func(filePath string)) { w.onTriggerFn = fn } Wiretap.SetDirs Sets the directories to be listened to. It is important to specify that it is the directory and all files in it that is listened to. One directory and all files in it is one ObservedElement . Subdirectories are already considered new ObservedElement . func (w *Wiretap) SetDirs(dirs []string) { w.dirs = dirs } Wiretap.SetExcludeDirs Excludes the directory and absolutely all subdirectories from listening. func (w *Wiretap) SetExcludeDirs(dirs []string) { w.excludeDirs = dirs } Wiretap.SetFiles Adds individual files to the wiretap. func (w *Wiretap) SetFiles(files []string) { w.files = files } Wiretap.Start Starts listening. Performs some initialization actions. func (w *Wiretap) Start() error { if err := w.initInotify(); err != nil { return err } w.collectTrackedElements() w.processingTrackedElemetns() if w.GetOnStartFunc() != nil { w.GetOnStartFunc()() } var buffer []uint8 for { buffer = make([]byte, syscall.SizeofInotifyEvent+4096) n, err := syscall.Read(int(w.initFD), buffer) if err != nil { return fmt.Errorf(\"error reading from inotify descriptor: %s\", err.Error()) } for i := 0; i < n; { event := (*InotifyEvent)(unsafe.Pointer(&buffer[i])) observedElement := w.observedElements[event.Wd-1] if !observedElement.Ready() { i += int(syscall.SizeofInotifyEvent) + int(event.Len) continue } if w.onTriggerFn != nil { w.onTriggerFn(observedElement.Path) } observedElement.LastEventTime = time.Now() i += int(syscall.SizeofInotifyEvent) + int(event.Len) } } }","title":"Wiretap"},{"location":"server/livereload/wiretap/#wiretap","text":"Starts listening to selected files using the InotifyEvent system event. When at least one file save is detected, it calls the trigger function.","title":"wiretap"},{"location":"server/livereload/wiretap/#setobservereventdelay","text":"Pause time between the execution of an event for one observation. This delay applies to each observation separately. func SetObserverEventDelay(delay int) { observedEventDelay = time.Duration(delay) * time.Millisecond }","title":"SetObserverEventDelay"},{"location":"server/livereload/wiretap/#observedelement","text":"One element to track, file or directory (all files in it are tracked).","title":"ObservedElement"},{"location":"server/livereload/wiretap/#observedelementready","text":"Shows whether the delay between invents has passed and whether the file is ready before the re-invent. func (of *ObservedElement) Ready() bool { return time.Since(of.LastEventTime) > observedEventDelay }","title":"ObservedElement.Ready"},{"location":"server/livereload/wiretap/#wiretap_1","text":"An object that monitors files and triggers an event when one of them is saved. The global algorithm works as follows: The user sets up the elements to be monitored. The elements to be monitored are processed and start listening using syscall.SYS_INOTIFY_ADD_WATCH . A cycle is started that waits for InotifyEvent and processes it. When InotifyEvent occurs, the trigger is activated.","title":"Wiretap"},{"location":"server/livereload/wiretap/#wiretaponstart","text":"Starts every time during the start of the wiretapping. The method is usually needed for preliminary initialization before monitoring begins. func (w *Wiretap) OnStart(fn func()) { w.onStartFn = fn }","title":"Wiretap.OnStart"},{"location":"server/livereload/wiretap/#wiretapontrigger","text":"A function that will be executed each time the trigger is executed. func (w *Wiretap) OnTrigger(fn func(filePath string)) { w.onTriggerFn = fn }","title":"Wiretap.OnTrigger"},{"location":"server/livereload/wiretap/#wiretapsetdirs","text":"Sets the directories to be listened to. It is important to specify that it is the directory and all files in it that is listened to. One directory and all files in it is one ObservedElement . Subdirectories are already considered new ObservedElement . func (w *Wiretap) SetDirs(dirs []string) { w.dirs = dirs }","title":"Wiretap.SetDirs"},{"location":"server/livereload/wiretap/#wiretapsetexcludedirs","text":"Excludes the directory and absolutely all subdirectories from listening. func (w *Wiretap) SetExcludeDirs(dirs []string) { w.excludeDirs = dirs }","title":"Wiretap.SetExcludeDirs"},{"location":"server/livereload/wiretap/#wiretapsetfiles","text":"Adds individual files to the wiretap. func (w *Wiretap) SetFiles(files []string) { w.files = files }","title":"Wiretap.SetFiles"},{"location":"server/livereload/wiretap/#wiretapstart","text":"Starts listening. Performs some initialization actions. func (w *Wiretap) Start() error { if err := w.initInotify(); err != nil { return err } w.collectTrackedElements() w.processingTrackedElemetns() if w.GetOnStartFunc() != nil { w.GetOnStartFunc()() } var buffer []uint8 for { buffer = make([]byte, syscall.SizeofInotifyEvent+4096) n, err := syscall.Read(int(w.initFD), buffer) if err != nil { return fmt.Errorf(\"error reading from inotify descriptor: %s\", err.Error()) } for i := 0; i < n; { event := (*InotifyEvent)(unsafe.Pointer(&buffer[i])) observedElement := w.observedElements[event.Wd-1] if !observedElement.Ready() { i += int(syscall.SizeofInotifyEvent) + int(event.Len) continue } if w.onTriggerFn != nil { w.onTriggerFn(observedElement.Path) } observedElement.LastEventTime = time.Now() i += int(syscall.SizeofInotifyEvent) + int(event.Len) } } }","title":"Wiretap.Start"},{"location":"typeopr/typeopr/","text":"typeopr This package contains functions for working with data types. IsPointer Checks if the value is a pointer. func IsPointer(a any) bool { return reflect.TypeOf(a).Kind() == reflect.Pointer } PtrIsStruct Checks if the value is a pointer to a structure. func PtrIsStruct(a any) bool { return reflect.TypeOf(a).Elem().Kind() == reflect.Struct } IsEmpty Checks if the value is empty. func IsEmpty(value interface{}) bool { v := reflect.ValueOf(value) switch v.Kind() { case reflect.String: return v.Len() == 0 case reflect.Array, reflect.Slice, reflect.Map, reflect.Chan: return v.Len() == 0 case reflect.Ptr, reflect.Interface: return v.IsNil() case reflect.Struct: return v.NumField() == 0 case reflect.Invalid: return true } return reflect.DeepEqual(value, reflect.Zero(v.Type()).Interface()) } AnyToBytes Converts input data into bytes. func AnyToBytes(value interface{}) ([]byte, error) { var buf bytes.Buffer val := reflect.ValueOf(value) if val.Kind() == reflect.Ptr { val = val.Elem() } switch val.Kind() { case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64: buf.WriteString(fmt.Sprintf(\"%v\", val.Int())) case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64: buf.WriteString(fmt.Sprintf(\"%v\", val.Uint())) case reflect.Float32, reflect.Float64: buf.WriteString(fmt.Sprintf(\"%v\", val.Float())) case reflect.String: buf.WriteString(val.String()) default: return nil, fmt.Errorf(\"unsupported convert type %s\", val.Kind().String()) } return buf.Bytes(), nil } Ptr An object designed to store a pointer. This object guarantees that it will store a pointer. Ptr.New Creating a new object Ptr . It is also guaranteed that a pointer will be stored inside this object. func (p Ptr) New(value interface{}) IPtr { if !IsPointer(value) { panic(ErrValueNotPointer{Value: fmt.Sprintf(\"Ptr<%s>\", reflect.TypeOf(value))}) } p.value = value return p } Prt.Ptr Returns a pointer that is stored in the object. func (p Ptr) Ptr() interface{} { return p.value } IsImplementInterface Determines whether an object uses an interface. If reflect.Value is used, you can use direct passing or passing by pointer, that is, passing a pointer to a pointer. How to transmit this data depends on the situation. func IsImplementInterface(objectPtr IPtr, interfaceType interface{}) bool { object := objectPtr.Ptr() // If the type of data passed directly is the desired interface. if reflect.TypeOf(object) == reflect.TypeOf(interfaceType) { return true } var objType reflect.Type if reflect.TypeOf(object).Elem() == reflect.TypeOf(reflect.Value{}) { objType = object.(*reflect.Value).Type() } else { objType = reflect.TypeOf(object) } intrfcType := reflect.TypeOf(interfaceType).Elem() return objType.Implements(intrfcType) } Usage example: object := MyObject{} IsImplementInterface(typeopr.Ptr{}.New(&object), (*MyInterface)(nil)) GetReflectValue Get reflect.Value from the passed value. func GetReflectValue[T any](target *T) reflect.Value { var v reflect.Value if reflect.TypeOf(*target) == typeReflectValue { v = *reflect.ValueOf(target).Interface().(*reflect.Value) } else { v = reflect.ValueOf(target).Elem() } return v }","title":"Typeopr"},{"location":"typeopr/typeopr/#typeopr","text":"This package contains functions for working with data types.","title":"typeopr"},{"location":"typeopr/typeopr/#ispointer","text":"Checks if the value is a pointer. func IsPointer(a any) bool { return reflect.TypeOf(a).Kind() == reflect.Pointer }","title":"IsPointer"},{"location":"typeopr/typeopr/#ptrisstruct","text":"Checks if the value is a pointer to a structure. func PtrIsStruct(a any) bool { return reflect.TypeOf(a).Elem().Kind() == reflect.Struct }","title":"PtrIsStruct"},{"location":"typeopr/typeopr/#isempty","text":"Checks if the value is empty. func IsEmpty(value interface{}) bool { v := reflect.ValueOf(value) switch v.Kind() { case reflect.String: return v.Len() == 0 case reflect.Array, reflect.Slice, reflect.Map, reflect.Chan: return v.Len() == 0 case reflect.Ptr, reflect.Interface: return v.IsNil() case reflect.Struct: return v.NumField() == 0 case reflect.Invalid: return true } return reflect.DeepEqual(value, reflect.Zero(v.Type()).Interface()) }","title":"IsEmpty"},{"location":"typeopr/typeopr/#anytobytes","text":"Converts input data into bytes. func AnyToBytes(value interface{}) ([]byte, error) { var buf bytes.Buffer val := reflect.ValueOf(value) if val.Kind() == reflect.Ptr { val = val.Elem() } switch val.Kind() { case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64: buf.WriteString(fmt.Sprintf(\"%v\", val.Int())) case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64: buf.WriteString(fmt.Sprintf(\"%v\", val.Uint())) case reflect.Float32, reflect.Float64: buf.WriteString(fmt.Sprintf(\"%v\", val.Float())) case reflect.String: buf.WriteString(val.String()) default: return nil, fmt.Errorf(\"unsupported convert type %s\", val.Kind().String()) } return buf.Bytes(), nil }","title":"AnyToBytes"},{"location":"typeopr/typeopr/#ptr","text":"An object designed to store a pointer. This object guarantees that it will store a pointer.","title":"Ptr"},{"location":"typeopr/typeopr/#ptrnew","text":"Creating a new object Ptr . It is also guaranteed that a pointer will be stored inside this object. func (p Ptr) New(value interface{}) IPtr { if !IsPointer(value) { panic(ErrValueNotPointer{Value: fmt.Sprintf(\"Ptr<%s>\", reflect.TypeOf(value))}) } p.value = value return p }","title":"Ptr.New"},{"location":"typeopr/typeopr/#prtptr","text":"Returns a pointer that is stored in the object. func (p Ptr) Ptr() interface{} { return p.value }","title":"Prt.Ptr"},{"location":"typeopr/typeopr/#isimplementinterface","text":"Determines whether an object uses an interface. If reflect.Value is used, you can use direct passing or passing by pointer, that is, passing a pointer to a pointer. How to transmit this data depends on the situation. func IsImplementInterface(objectPtr IPtr, interfaceType interface{}) bool { object := objectPtr.Ptr() // If the type of data passed directly is the desired interface. if reflect.TypeOf(object) == reflect.TypeOf(interfaceType) { return true } var objType reflect.Type if reflect.TypeOf(object).Elem() == reflect.TypeOf(reflect.Value{}) { objType = object.(*reflect.Value).Type() } else { objType = reflect.TypeOf(object) } intrfcType := reflect.TypeOf(interfaceType).Elem() return objType.Implements(intrfcType) } Usage example: object := MyObject{} IsImplementInterface(typeopr.Ptr{}.New(&object), (*MyInterface)(nil))","title":"IsImplementInterface"},{"location":"typeopr/typeopr/#getreflectvalue","text":"Get reflect.Value from the passed value. func GetReflectValue[T any](target *T) reflect.Value { var v reflect.Value if reflect.TypeOf(*target) == typeReflectValue { v = *reflect.ValueOf(target).Interface().(*reflect.Value) } else { v = reflect.ValueOf(target).Elem() } return v }","title":"GetReflectValue"},{"location":"utils/fmap/fmap/","text":"fmap MergeMap Merges two maps into one. For example, if you pass Map1 and Map2, Map2 data will be added to Map1. func MergeMap[T1 comparable, T2 any](map1 *map[T1]T2, map2 map[T1]T2) { for key, value := range map2 { (*map1)[key] = value } } MergeMapSync Merges two maps into one. For example, if you pass Map1 and Map2, Map2 data will be added to Map1. Safe for use in asynchronous mode. func MergeMapSync[T1 comparable, T2 any](mu *sync.Mutex, map1 *map[T1]T2, map2 map[T1]T2) { mu.Lock() defer mu.Unlock() for key, value := range map2 { (*map1)[key] = value } } YamlMapToStruct Writes a yaml map to the structure. IMPORTANT: the field of the structure to be written must have the yaml tag:\"<field_name>\" . This name must correspond to the name of the field in the targetMap structure. Works in depth, you can make as many attachments as you want. func YamlMapToStruct(targetMap *map[string]interface{}, targetStruct typeopr.IPtr) error { for mFieldName, mFieldValue := range *targetMap { var sValue reflect.Value var sType reflect.Type if reflect.DeepEqual(reflect.TypeOf(targetStruct.Ptr()).Elem(), reflect.TypeOf(reflect.Value{})) { sValue = *targetStruct.Ptr().(*reflect.Value) sType = sValue.Type() } else { sValue = reflect.ValueOf(targetStruct.Ptr()).Elem() sType = reflect.TypeOf(targetStruct.Ptr()).Elem() } for i := 0; i < sType.NumField(); i++ { if sType.Field(i).Tag.Get(\"yaml\") == mFieldName { if sValue.CanSet() { fieldValue := sValue.Field(i) mapFieldValue := reflect.ValueOf(mFieldValue) if err := convertYamlField(&fieldValue, &mapFieldValue); err != nil { return err } } else { return fmt.Errorf(\"the %s field cannot be set to a value\", sType.Field(i).Name) } } } } return nil }","title":"fmap"},{"location":"utils/fmap/fmap/#fmap","text":"","title":"fmap"},{"location":"utils/fmap/fmap/#mergemap","text":"Merges two maps into one. For example, if you pass Map1 and Map2, Map2 data will be added to Map1. func MergeMap[T1 comparable, T2 any](map1 *map[T1]T2, map2 map[T1]T2) { for key, value := range map2 { (*map1)[key] = value } }","title":"MergeMap"},{"location":"utils/fmap/fmap/#mergemapsync","text":"Merges two maps into one. For example, if you pass Map1 and Map2, Map2 data will be added to Map1. Safe for use in asynchronous mode. func MergeMapSync[T1 comparable, T2 any](mu *sync.Mutex, map1 *map[T1]T2, map2 map[T1]T2) { mu.Lock() defer mu.Unlock() for key, value := range map2 { (*map1)[key] = value } }","title":"MergeMapSync"},{"location":"utils/fmap/fmap/#yamlmaptostruct","text":"Writes a yaml map to the structure. IMPORTANT: the field of the structure to be written must have the yaml tag:\"<field_name>\" . This name must correspond to the name of the field in the targetMap structure. Works in depth, you can make as many attachments as you want. func YamlMapToStruct(targetMap *map[string]interface{}, targetStruct typeopr.IPtr) error { for mFieldName, mFieldValue := range *targetMap { var sValue reflect.Value var sType reflect.Type if reflect.DeepEqual(reflect.TypeOf(targetStruct.Ptr()).Elem(), reflect.TypeOf(reflect.Value{})) { sValue = *targetStruct.Ptr().(*reflect.Value) sType = sValue.Type() } else { sValue = reflect.ValueOf(targetStruct.Ptr()).Elem() sType = reflect.TypeOf(targetStruct.Ptr()).Elem() } for i := 0; i < sType.NumField(); i++ { if sType.Field(i).Tag.Get(\"yaml\") == mFieldName { if sValue.CanSet() { fieldValue := sValue.Field(i) mapFieldValue := reflect.ValueOf(mFieldValue) if err := convertYamlField(&fieldValue, &mapFieldValue); err != nil { return err } } else { return fmt.Errorf(\"the %s field cannot be set to a value\", sType.Field(i).Name) } } } } return nil }","title":"YamlMapToStruct"},{"location":"utils/fpath/fpath/","text":"fpath CurrentFileDir Returns the path to the directory in which this function is called. func CurrentFileDir() string { _, file, _, _ := runtime.Caller(1) return filepath.Dir(file) } PathExist Checks to see if a path exists in the file directory. func PathExist(path string) bool { _, err := os.Stat(path) return !os.IsNotExist(err) }","title":"fpath"},{"location":"utils/fpath/fpath/#fpath","text":"","title":"fpath"},{"location":"utils/fpath/fpath/#currentfiledir","text":"Returns the path to the directory in which this function is called. func CurrentFileDir() string { _, file, _, _ := runtime.Caller(1) return filepath.Dir(file) }","title":"CurrentFileDir"},{"location":"utils/fpath/fpath/#pathexist","text":"Checks to see if a path exists in the file directory. func PathExist(path string) bool { _, err := os.Stat(path) return !os.IsNotExist(err) }","title":"PathExist"},{"location":"utils/fslice/fslice/","text":"fslice SliceContains Checks to see if the slice contains a value. func SliceContains[T comparable](slice []T, item T) bool { for i := 0; i < len(slice); i++ { if slice[i] == item { return true } } return false } AllStringItemsEmpty Checks if all items in the slice are empty strings. func AllStringItemsEmpty(slice []string) bool { for i := 0; i < len(slice); i++ { if slice[i] != \"\" { return false } } return true }","title":"fslice"},{"location":"utils/fslice/fslice/#fslice","text":"","title":"fslice"},{"location":"utils/fslice/fslice/#slicecontains","text":"Checks to see if the slice contains a value. func SliceContains[T comparable](slice []T, item T) bool { for i := 0; i < len(slice); i++ { if slice[i] == item { return true } } return false }","title":"SliceContains"},{"location":"utils/fslice/fslice/#allstringitemsempty","text":"Checks if all items in the slice are empty strings. func AllStringItemsEmpty(slice []string) bool { for i := 0; i < len(slice); i++ { if slice[i] != \"\" { return false } } return true }","title":"AllStringItemsEmpty"},{"location":"utils/fstring/fstring/","text":"fstring ToLower Converts the first letter of a string to lowercase. func ToLower(value string) string { for i, v := range value { return string(unicode.ToLower(v)) + value[i+1:] } return \"\" }","title":"fstring"},{"location":"utils/fstring/fstring/#fstring","text":"","title":"fstring"},{"location":"utils/fstring/fstring/#tolower","text":"Converts the first letter of a string to lowercase. func ToLower(value string) string { for i, v := range value { return string(unicode.ToLower(v)) + value[i+1:] } return \"\" }","title":"ToLower"},{"location":"utils/fstruct/fstruct/","text":"fstruct CheckNotDefaultFields Checks whether the values \u200b\u200bof the structure fields are default. That is, if the field is not passed or initialized with standard values, for example, nil. func CheckNotDefaultFields(objectPtr typeopr.IPtr) error { objectLink := objectPtr.Ptr() var rObjectValue reflect.Value var rObjectType reflect.Type if reflect.TypeOf(objectLink).Elem() == reflect.TypeOf(reflect.Value{}) { rObjectValue = objectLink.(*reflect.Value).Elem() rObjectType = objectLink.(*reflect.Value).Elem().Type() } else { rObjectValue = reflect.ValueOf(objectLink).Elem() rObjectType = reflect.TypeOf(objectLink).Elem() } for i := 0; i < rObjectType.NumField(); i++ { fieldType := rObjectType.Field(i) fieldValue := rObjectValue.Field(i) tag := fieldType.Tag.Get(\"notdef\") if tag == \"\" { continue } reqiredValue, err := strconv.ParseBool(tag) if err != nil { return err } if reqiredValue { if fieldValue.IsZero() { return ErrStructFieldIsDefault{fieldType.Name} } } } return nil }","title":"fstruct"},{"location":"utils/fstruct/fstruct/#fstruct","text":"","title":"fstruct"},{"location":"utils/fstruct/fstruct/#checknotdefaultfields","text":"Checks whether the values \u200b\u200bof the structure fields are default. That is, if the field is not passed or initialized with standard values, for example, nil. func CheckNotDefaultFields(objectPtr typeopr.IPtr) error { objectLink := objectPtr.Ptr() var rObjectValue reflect.Value var rObjectType reflect.Type if reflect.TypeOf(objectLink).Elem() == reflect.TypeOf(reflect.Value{}) { rObjectValue = objectLink.(*reflect.Value).Elem() rObjectType = objectLink.(*reflect.Value).Elem().Type() } else { rObjectValue = reflect.ValueOf(objectLink).Elem() rObjectType = reflect.TypeOf(objectLink).Elem() } for i := 0; i < rObjectType.NumField(); i++ { fieldType := rObjectType.Field(i) fieldValue := rObjectValue.Field(i) tag := fieldType.Tag.Get(\"notdef\") if tag == \"\" { continue } reqiredValue, err := strconv.ParseBool(tag) if err != nil { return err } if reqiredValue { if fieldValue.IsZero() { return ErrStructFieldIsDefault{fieldType.Name} } } } return nil }","title":"CheckNotDefaultFields"}]}